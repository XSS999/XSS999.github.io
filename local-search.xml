<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2023/02/22/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/02/22/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. Ctrl c：取消命令，并且换行<br>2. Ctrl u：清空本行命令<br>3. tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项<br>4. ls：列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件<br>ㅤㅤㅤ●ㅤls -a：查看所有文件包括隐藏文件（以.开头的文件就是隐藏文件）<br>ㅤㅤㅤ●ㅤls -l：查看当前路径下文件的读、写、执行权限<br>ㅤㅤㅤ●ㅤls | wc -l：查看ls下有多少个文件<br>5. pwd：显示当前路径<br>6. cd XXX：进入XXX目录下，cd ..返回上层目录<br>ㅤㅤㅤ●ㅤ.：当前目录 ..：上级目录<br>ㅤㅤㅤ●ㅤ~：家目录，回回到路径/home/acs下<br>ㅤㅤㅤ●ㅤcd -：返回改变路径前的路径，比如当前在/home/acs/homework然后cd** **/这个时候就处于/目录下，然后cd -就会回到改变路径前的路径也就是/home/acs/homework<br>7. cp XXX YYY：将XXX文件复制成YYY，XXX和YYY可以是同一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt<br>ㅤㅤㅤ●ㅤcp XXX YYY -r将XXX目录（文件夹）复制到YYY下<br>ㅤㅤㅤ●ㅤ非当前路径重命名方法：cp a.txt ../b.txt<br>8. mkdir XXX：创建目录（文件夹）XXX<br>ㅤㅤㅤ●ㅤmkdir -p：-p：如果文件夹不存在，则创建<br>9. rm XXX：删除普通文件； rm XXX -r：删除文件夹<br>ㅤㅤㅤ●ㅤ支持正则表达式，删除所有.txt类型文件：rm *.txt<br>ㅤㅤㅤ●ㅤ删除所有文件（不包括文件夹）：rm *<br>ㅤㅤㅤ●ㅤ正则表达式删除所有文件夹：rm * -r即可<br>10. mv XXX YYY：将XXX文件移动到YYY下，和cp命令一样，XXX和YYY可以是同一个路径；重命名也是用这个命令<br>ㅤㅤㅤ●ㅤ非当前路径移动方法：mv a.txt ../b.txt<br>11. touch XXX：创建一个文件<br>12. cat XXX：展示文件XXX中的内容<br>13. 复制文本：windows/Linux下：Ctrl + insert，Mac下：command + c<br>14. 粘贴文本：windows/Linux下：Shift + insert，Mac下：command + v<br>15. history：查看历史输入指令<br>16. tree：以树形显示文件目录结构<br></code></pre></td></tr></table></figure><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="git基本概念"><a href="#git基本概念" class="headerlink" title="git基本概念"></a>git基本概念</h2><ul><li><strong>工作区</strong> ：仓库的目录。工作区是独立于各个分支的。</li><li><strong>暂存区</strong>：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。</li><li><strong>版本库</strong>：存放所有已经提交到本地仓库的代码版本</li><li><strong>版本结构</strong>：树结构，树中每个节点代表一个代码版本。</li></ul><h2 id="git命令分类整理"><a href="#git命令分类整理" class="headerlink" title="git命令分类整理"></a>git命令分类整理</h2><h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><ol><li><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在~&#x2F;.gitconfig文件中</li><li><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在~&#x2F;.gitconfig文件中</li><li><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中</li></ol><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><code>git status</code>：查看仓库状态</li><li><code>git add XX</code> ：将XX文件添加到暂存区</li></ol><ul><li><code>git add .</code>：将工作区所有文件添加到缓存区</li></ul><ol><li><code>git commit -m</code> ：”给自己看的备注信息”：将暂存区的内容提交到当前分支</li><li><code>git log</code>：查看当前分支的所有版本</li><li><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code><strong>：将本地仓库关联到远程仓库</strong></li><li><code>git push -u</code>： (第一次需要-u以后不需要) ：将当前分支推送到远程仓库</li><li><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</li><li><code>git branch</code>：查看所有分支和当前所处分支</li></ol><h3 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h3><p><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容</p><p><code>git status</code>：查看仓库状态</p><p><code>git log</code>：查看当前分支的所有版本</p><p><code>git log --pretty=oneline</code>：用一行来显示</p><p><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</p><p><code>git branch</code>：查看所有分支和当前所处分支</p><p><code>git pull</code> ：将远程仓库的当前分支与本地仓库的当前分支合并</p><h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><p><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉，不希望管理这个文件</p><p><code>git restore --staged xx</code>：将xx从暂存区里移除</p><p><code>git checkout — XX或git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销</p><h3 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h3><p><code>git reset --hard HEAD^ 或git reset --hard HEAD~</code> ：将代码库回滚到上一个版本</p><p><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</p><p><code>git reset --hard HEAD~100</code>：往上回滚100个版本</p><p><code>git reset --hard 版本号</code>：回滚到某一特定版本</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</p><p><code>git push -u origin master(第一次需要-u以后不需要)</code> ：将当前分支推送到远程仓库</p><p><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</p><p><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下</p><p><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支</p><p><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支</p><p><code>git checkout -t origin/branch_name</code>：将远程的branch_name分支拉取到本地</p><p><code>git pull</code> ：将远程仓库的当前分支与本地仓库的当前分支合并</p><p><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并</p><p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</p><h3 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h3><p><code>git branch branch_name</code>：创建新分支</p><p><code>git branch</code>：查看所有分支和当前所处分支</p><p><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支</p><p><code>git checkout branch_name</code>：切换到branch_name这个分支</p><p><code>git merge branch_name</code>：将分支branch_name合并到当前分支上</p><p><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</p><p><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支</p><p><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支</p><p><code>git checkout -t origin/branch_name</code> ：将远程的branch_name分支拉取到本地</p><p><code>git pull</code> ：将远程仓库的当前分支与本地仓库的当前分支合并</p><p><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并</p><p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</p><h3 id="stash暂存"><a href="#stash暂存" class="headerlink" title="stash暂存"></a>stash暂存</h3><p><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</p><p><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</p><p><code>git stash drop</code>：删除栈顶存储的修改</p><p><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</p><p><code>git stash list</code>：查看栈中所有元素</p><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs shell">功能：<br>    (1) 命令行模式下的文本编辑器。<br>    (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。<br>    (3) 使用方式：vim filename<br>        如果已有该文件，则打开它。<br>        如果没有该文件，则打开个一个新的文件，并命名为filename<br>模式：<br>    (1) 一般命令模式<br>        默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。<br>    (2) 编辑模式<br>        在一般命令模式里按下i，会进入编辑模式。<br>        按下ESC会退出编辑模式，返回到一般命令模式。<br>    (3) 命令行模式<br>        在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。<br>        可以查找、替换、保存、退出、配置编辑器等。<br>操作：<br>    (1) i：进入编辑模式<br>    (2) ESC：进入一般命令模式<br>    (3) h 或 左箭头键：光标向左移动一个字符<br>    (4) j 或 向下箭头：光标向下移动一个字符<br>    (5) k 或 向上箭头：光标向上移动一个字符<br>    (6) l 或 向右箭头：光标向右移动一个字符<br>    (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符<br>    (8) 0 或 功能键[Home]：光标移动到本行开头<br>    (9) $ 或 功能键[End]：光标移动到本行末尾<br>    (10) G：光标移动到最后一行<br>    (11) :n 或 nG：n为数字，光标移动到第n行<br>    (12) gg：光标移动到第一行，相当于1G<br>    (13) n&lt;Enter&gt;：n为数字，光标向下移动n行<br>    (14) /word：向光标之下寻找第一个值为word的字符串。<br>    (15) ?word：向光标之上寻找第一个值为word的字符串。<br>    (16) n：重复前一个查找操作<br>    (17) N：反向重复前一个查找操作<br>    (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2<br>    (19) :1,$s/word1/word2/g：将全文的word1替换为word2<br>    (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。<br>    (21) v：选中文本<br>    (22) d：删除选中的文本<br>    (23) dd: 删除当前行<br>    (24) y：复制选中的文本<br>    (25) yy: 复制当前行<br>    (26) p: 将复制的数据在光标的下一行/下一个位置粘贴<br>    (27) u：撤销<br>    (28) Ctrl + r：取消撤销<br>    (29) 大于号 &gt;：将选中的文本整体向右缩进一次<br>    (30) 小于号 &lt;：将选中的文本整体向左缩进一次<br>    (31) :w 保存<br>    (32) :w! 强制保存<br>    (33) :q 退出<br>    (34) :q! 强制退出<br>    (35) :wq 保存并退出<br>    (36) :set paste 设置成粘贴模式，取消代码自动缩进<br>    (37) :set nopaste 取消粘贴模式，开启代码自动缩进<br>    (38) :set nu 显示行号<br>    (39) :set nonu 隐藏行号<br>    (40) gg=G：将全文代码格式化<br>    (41) :noh 关闭查找关键词高亮<br>    (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令<br>异常处理：<br>    每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。<br>    如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：<br>        (1) 找到正在打开该文件的程序，并退出<br>        (2) 直接删掉该swp文件即可<br></code></pre></td></tr></table></figure><h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell">功能：<br>    (1) 分屏。<br>    (2) 允许断开Terminal连接后，继续运行进程。<br>结构：<br>    一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。<br>    实例：<br>        tmux:<br>            session 0:<br>                window 0:<br>                    pane 0<br>                    pane 1<br>                    pane 2<br>                    ...<br>                window 1<br>                window 2<br>                ...<br>            session 1<br>            session 2<br>            ...<br>操作：<br>    (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。<br>    (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。<br>    (3) 按下Ctrl + a后手指松开，然后按&quot;（注意是双引号&quot;）：将当前pane上下平分成两个pane。<br>    (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。<br>    (5) 鼠标点击可以选pane。<br>    (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。<br>    (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。<br>    (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。<br>    (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。<br>    (10) 按下ctrl + a后手指松开，然后按d：挂起当前session。<br>    (11) tmux a：打开之前挂起的session。<br>    (12) 按下ctrl + a后手指松开，然后按s：选择其它session。<br>        方向键 —— 上：选择上一项 session/window/pane<br>        方向键 —— 下：选择下一项 session/window/pane<br>        方向键 —— 右：展开当前项 session/window<br>        方向键 —— 左：闭合当前项 session/window<br>    (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。<br>    (14) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。<br>    (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。<br>    (16) 鼠标滚轮：翻阅当前pane内的内容。<br>    (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）<br>    (18) tmux中复制/粘贴文本的通用方式：<br>        (1) 按下Ctrl + a后松开手指，然后按[<br>        (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板<br>        (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处<br></code></pre></td></tr></table></figure><h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>shell是我们通过命令行与操作系统沟通的语言。<br>shell脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。<br>AC Terminal中的命令行可以看成是一个“shell脚本在逐行执行”。<br>Linux中常见的shell脚本有很多种，常见的有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Bourne Shell(/usr/bin/sh或/bin/sh)<br>Bourne Again Shell(/bin/bash)<br>C Shell(/usr/bin/csh)<br>K Shell(/usr/bin/ksh)<br>zsh<br></code></pre></td></tr></table></figure><p>Linux系统中一般默认使用bash，所以接下来讲解bash中的语法。<br>文件开头需要写#! &#x2F;bin&#x2F;bash，指明bash为脚本解释器。</p><h3 id="脚本示例"><a href="#脚本示例" class="headerlink" title="脚本示例"></a>脚本示例</h3><p>新建一个test.sh文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br>echo &quot;Hello World!&quot;<br></code></pre></td></tr></table></figure><p>运行方式：作为可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh  # 使脚本具有可执行权限<br>acs@9e0ebfcd82d7:~$ ./test.sh  # 当前路径下执行<br>Hello World!  # 脚本输出<br>acs@9e0ebfcd82d7:~$ /home/acs/test.sh  # 绝对路径下执行<br>Hello World!  # 脚本输出<br>acs@9e0ebfcd82d7:~$ ~/test.sh  # 家目录路径下执行<br>Hello World!  # 脚本输出<br></code></pre></td></tr></table></figure><p>用解释器执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">acs@9e0ebfcd82d7:~$ bash test.sh<br>Hello World!  # 脚本输出<br></code></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>每行中#之后的内容均是注释。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"> #</span><span class="language-bash">这是一行注释</span><br>echo &#x27;Hello World&#x27;  #  这也是注释<br></code></pre></td></tr></table></figure><h3 id="多行注释："><a href="#多行注释：" class="headerlink" title="多行注释："></a>多行注释：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">:&lt;&lt;EOF<br>第一行注释<br>第二行注释<br>第三行注释<br>EOF<br></code></pre></td></tr></table></figure><p>其中EOF可以换成其它任意字符串。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">:&lt;&lt;abc<br>第一行注释<br>第二行注释<br>第三行注释<br>abc<br><br>:&lt;&lt;!<br>第一行注释<br>第二行注释<br>第三行注释<br>!<br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量，不需要加$符号，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">name1=&#x27;yxc&#x27;  # 单引号定义字符串<br>name2=&quot;yxc&quot;  # 双引号定义字符串<br>name3=yxc    # 也可以不加引号，同样表示字符串<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc<br>echo $name  # 输出yxc<br>echo $&#123;name&#125;  # 输出yxc<br>echo $&#123;name&#125;acwing  # 输出yxcacwing<br></code></pre></td></tr></table></figure><h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>使用readonly或者declare可以将变量变为只读。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc<br>readonly name<br>declare -r name  # 两种写法均可<br><br>name=abc  # 会报错，因为此时name只读<br></code></pre></td></tr></table></figure><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>unset可以删除变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc<br>unset name<br>echo $name  # 输出空行<br></code></pre></td></tr></table></figure><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li>自定义变量（局部变量）<br>子进程不能访问的变量</li><li>环境变量（全局变量）<br>子进程可以访问的变量<br>自定义变量改成环境变量：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ name=yxc  # 定义变量<br>acs@9e0ebfcd82d7:~$ export name  # 第一种方法<br>acs@9e0ebfcd82d7:~$ declare -x name  # 第二种方法<br></code></pre></td></tr></table></figure><p>环境变量改为自定义变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ export name=yxc  # 定义环境变量<br>acs@9e0ebfcd82d7:~$ declare +x name  # 改为自定义变量<br></code></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串可以用单引号，也可以用双引号，也可以不用引号。<br>单引号与双引号的区别：<br>单引号中的内容会原样输出，不会执行、不会取变量；<br>双引号中的内容可以执行、可以取变量；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=yxc  # 不用引号<br>echo &#x27;hello, $name \&quot;hh\&quot;&#x27;  # 单引号字符串，输出 hello, $name \&quot;hh\&quot;<br>echo &quot;hello, $name \&quot;hh\&quot;&quot;  # 双引号字符串，输出 hello, yxc &quot;hh&quot;<br></code></pre></td></tr></table></figure><p>获取字符串长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=&quot;yxc&quot;<br>echo $&#123;#name&#125;  # 输出3<br></code></pre></td></tr></table></figure><p>提取子串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=&quot;hello, yxc&quot;<br>echo $&#123;name:0:5&#125;  # 提取从0开始的5个字符<br></code></pre></td></tr></table></figure><h2 id="默认变量"><a href="#默认变量" class="headerlink" title="默认变量"></a>默认变量</h2><h3 id="文件参数变量"><a href="#文件参数变量" class="headerlink" title="文件参数变量"></a>文件参数变量</h3><p>在执行shell脚本时，可以向脚本传递参数。$1是第一个参数，$2是第二个参数，以此类推。特殊的，$0是文件名（包含路径）。例如：<br>创建文件test.sh：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">! /bin/bash</span><br><br>echo &quot;文件名：&quot;$0<br>echo &quot;第一个参数：&quot;$1<br>echo &quot;第二个参数：&quot;$2<br>echo &quot;第三个参数：&quot;$3<br>echo &quot;第四个参数：&quot;$4<br></code></pre></td></tr></table></figure><p>然后执行该脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">acs@9e0ebfcd82d7:~$ chmod +x test.sh <br>acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出</span><br>文件名：./test.sh<br>第一个参数：1<br>第二个参数：2<br>第三个参数：3<br>第四个参数：4<br></code></pre></td></tr></table></figure><h3 id="其它参数相关变量"><a href="#其它参数相关变量" class="headerlink" title="其它参数相关变量"></a>其它参数相关变量</h3><p><img src="/img/Photo/Linux/01.png"></p><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>将当前用户添加到docker用户组<br>为了避免每次使用docker命令都需要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组：<br><code>sudo usermod -aG docker $USER</code><br>执行完此操作后，需要退出服务器，再重新登录回来，才可以省去sudo权限。</p><p>镜像（images）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull ubuntu:20.04：拉取一个镜像<br>docker images：列出本地所有镜像<br>docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04：删除镜像ubuntu:20.04<br>docker [container] commit CONTAINER IMAGE_NAME:TAG：创建某个container的镜像<br>docker save -o ubuntu_20_04.tar ubuntu:20.04：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中<br>docker load -i ubuntu_20_04.tar：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来<br></code></pre></td></tr></table></figure><p>容器(container)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker [container] create -it ubuntu:20.04：利用镜像ubuntu:20.04创建一个容器。<br>docker ps -a：查看本地的所有容器<br>docker [container] start CONTAINER：启动容器<br>docker [container] stop CONTAINER：停止容器<br>docker [container] restart CONTAINER：重启容器<br>docker [contaienr] run -itd ubuntu:20.04：创建并启动一个容器<br>docker [container] attach CONTAINER：进入容器<br>先按Ctrl-p，再按Ctrl-q可以挂起容器<br>docker [container] exec CONTAINER COMMAND：在容器中执行命令<br>docker [container] rm CONTAINER：删除容器<br>docker container prune：删除所有已停止的容器<br>docker export -o xxx.tar CONTAINER：将容器CONTAINER导出到本地文件xxx.tar中<br>docker import xxx.tar image_name:tag：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag<br>docker export/import与docker save/load的区别：<br>export/import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态<br>save/load会保存完整记录，体积更大<br>docker top CONTAINER：查看某个容器内的所有进程<br>docker stats：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息<br>docker cp xxx CONTAINER:xxx 或 docker cp CONTAINER:xxx xxx：在本地和容器间复制文件<br>docker rename CONTAINER1 CONTAINER2：重命名容器<br>docker update CONTAINER --memory 500MB：修改容器限制<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2022/12/15/Algorithm/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2022/12/15/Algorithm/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>为了提高效率</p><p>快排和归并都用到了双指针</p><p>常见问题分类：</p><p>​    (1) 对于一个序列，用两个指针维护一段区间</p><p>​    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>重点在check(i,j)怎么写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//最长连续不重复子序列</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        b[a[i]]++;<br>        <span class="hljs-keyword">while</span>(b[a[i]]&gt;<span class="hljs-number">1</span>) <span class="hljs-comment">//这里没有j&lt;=i;因为加不加一样</span><br>        &#123;<br>            b[a[j]]--;<br>            j++;<br>        &#125;<br>        res=<span class="hljs-built_in">max</span>(res,i-j+<span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>其朴素算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(i,))res=<span class="hljs-built_in">max</span>(res,i-j+<span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼</title>
    <link href="/2022/12/11/%E5%93%88%E5%A4%AB%E6%9B%BC/"/>
    <url>/2022/12/11/%E5%93%88%E5%A4%AB%E6%9B%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是哈夫曼树："><a href="#什么是哈夫曼树：" class="headerlink" title="什么是哈夫曼树："></a>什么是哈夫曼树：</h1><p>给定N个权值作为N个叶子结点，构造一棵二叉树，<strong>若该树的带权路径长度（WPL）达到最小</strong>，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><p><strong>WPL计算方法</strong>: WPL&#x3D;求和(wi li)其中wi是第i个节点的权值(value)。li是第i个节点的长(深)度.</p><h1 id="哈夫曼树有什么用？"><a href="#哈夫曼树有什么用？" class="headerlink" title="哈夫曼树有什么用？"></a>哈夫曼树有什么用？</h1><ul><li>哈夫曼树主要用在<strong>数据的压缩</strong>如JPEG格式图片，在通信中我们可以先对发送的数据进行哈夫曼编码压缩数据提高传输速度。</li><li><strong>查询优化</strong>:在工作中我们我们身边放许多工具，由于空间限制我们不能把所有工具放在我们最容易拿到的地方，所有我们<strong>把使用频率最高的工具放在最容易的位置</strong>。同样的道理在查询的时候我们把查询频率最高的数据建立索引，这些都是使用了哈夫曼算法的思想。</li></ul><h1 id="怎么构建一个哈夫曼树？"><a href="#怎么构建一个哈夫曼树？" class="headerlink" title="怎么构建一个哈夫曼树？"></a>怎么构建一个哈夫曼树？</h1><p><img src="/img/Photo/Huffman/01.png"></p><p><img src="/img/Photo/Huffman/02.jpg"></p><p>哈夫曼树的结构定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ElemType</span>&#123;<br><span class="hljs-type">int</span> weight;<br><span class="hljs-type">int</span> parent,lchild,rchild;<br>&#125;;<br></code></pre></td></tr></table></figure><p>哈夫曼算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HuffmanTree</span><span class="hljs-params">(ElemType huffTree[],<span class="hljs-type">int</span> w[],<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,k,i1,i2;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;i++) <span class="hljs-comment">//先初始化，所有节点均没有双亲和孩子</span><br>    &#123;<br>        huffTree[i].parent = <span class="hljs-number">-1</span>;<br>        huffTree[i].lchild = huffTree[i<br>].rchrld = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;n;i++) huffTree[i].weight = w[i];<span class="hljs-comment">//存储叶子结点的权值</span><br>    <span class="hljs-keyword">for</span>( k = n;k&lt;<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;k++) <span class="hljs-comment">//n-1次合并</span><br>    &#123;<br>        <span class="hljs-built_in">Select</span>(huffTree,i1,i2);<span class="hljs-comment">//选出权值最小的节点的下标为i1和i2</span><br>        huffTree[k].weight = huffTree[i1].weight+huffTree[i2].weight;<br>        huffTree[i1].parent = k;<br>        huffTree[i2].parent = k;<br>        huffTree[k].lchild = i1;<br>        huffTree[k].rchild = i2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>任意字符的编码都不是另一字符的编码的前缀——前缀编码</p><p><strong>用于数据压缩</strong></p><ul><li>统计字符集中每个字符的平均出现频率。</li><li>以概率值作为权值构造哈夫曼树，频率越大的节点，路径越短。</li><li>在哈夫曼树的分枝上标上0 或 1：<strong>节点的左分支标0，右分支标1</strong>，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码。</li></ul><p><img src="/img/Photo/Huffman/03.jpg"></p><p><strong>解码的方法：</strong></p><ul><li>构造哈夫曼树</li><li>依次读入二进制码</li><li>读入0，则走向左孩子；读入1，则走向右孩子</li><li>一旦到达某叶子节点时，可译出字符</li><li>然后再从根出发继续译码，直到结束</li></ul>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++</title>
    <link href="/2022/05/26/Algorithm/C++/"/>
    <url>/2022/05/26/Algorithm/C++/</url>
    
    <content type="html"><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector（变长数组），倍增的思想，支持比较运算（按字典序）<br>    定义：：<br>        vector &lt;<span class="hljs-type">int</span>&gt; a; 定义：一个vector数组a<br>        vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">a</span>(<span class="hljs-number">10</span>); 定义：一个长度为<span class="hljs-number">10</span>的vector数组a<br>        vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">a</span>(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>); 定义：一个长度为<span class="hljs-number">10</span>的vector数组a，并且所有元素都为<span class="hljs-number">3</span><br>    常用函数：：<br>        <span class="hljs-built_in">size</span>(); 返回元素个数<br>        <span class="hljs-built_in">empty</span>(); 返回是否是空<br>        <span class="hljs-built_in">clear</span>(); 清空<br>        <span class="hljs-built_in">front</span>(); 返回vector的第一个数<br>        <span class="hljs-built_in">back</span>(); 返回vector的最后一个数<br>        <span class="hljs-built_in">push_back</span>(); 向vector的最后插入一个数<br>        <span class="hljs-built_in">pop_back</span>(); 把vector的最后一个数删掉<br>        <span class="hljs-built_in">begin</span>(); vector的第<span class="hljs-number">0</span>个数<br>        <span class="hljs-built_in">end</span>(); vector的最后一个的数的后面一个数<br>    倍增的思想：<br>        系统为某一程序分配空间是，所需时间，与空间大小无关，与申请次数有关<br>    遍历方法<br>        假设有个vector &lt;<span class="hljs-type">int</span>&gt; a;<br>        第一种：<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; a.<span class="hljs-built_in">size</span>();i ++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        第二种：<br>            <span class="hljs-keyword">for</span>(vector &lt;<span class="hljs-type">int</span>&gt;==iterator i = a.<span class="hljs-built_in">begin</span>();i != a.<span class="hljs-built_in">end</span>();i ++) cout&lt;&lt;*i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;  vector &lt;<span class="hljs-type">int</span>&gt;==iterator可以写为<span class="hljs-keyword">auto</span><br>        第三种：<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>  x : a) cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><br>pair，支持比较运算，以first为第一关键字，以second为第二关键字（按字典序）<br>    定义：：<br>        pair &lt;类型,类型&gt; 变量名;    两个类型可以不同<br>    初始化方式：<br>        假设有个pair &lt;<span class="hljs-type">int</span>,string&gt; p;<br>        第一种：<br>            p = <span class="hljs-built_in">make_pair</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&quot;abc&quot;</span>);<br>        第二种：<br>            p = &#123;<span class="hljs-number">10</span>,<span class="hljs-string">&quot;abc&quot;</span>);<br>    常用函数：：<br>        <span class="hljs-built_in">first</span>(); 第一个元素<br>        <span class="hljs-built_in">second</span>(); 第二个元素<br><br>string（字符串）<br>    常用函数：：<br>        <span class="hljs-built_in">substr</span>(); 返回每一个子串<br>        <span class="hljs-built_in">c_str</span>(); 返回这个string对应的字符数组的头指针<br>        <span class="hljs-built_in">size</span>(); 返回字母个数<br>        <span class="hljs-built_in">length</span>(); 返回字母个数<br>        <span class="hljs-built_in">empty</span>(); 返回字符串是否为空<br>        <span class="hljs-built_in">clear</span>(); 把字符串清空<br>queue（队列）<br>    定义：：<br>        queue &lt;类型&gt; 变量名;<br>    常用函数：：<br>        <span class="hljs-built_in">size</span>(); 这个队列的长度<br>        <span class="hljs-built_in">empty</span>(); 返回这个队列是否为空<br>        <span class="hljs-built_in">push</span>(); 往队尾插入一个元素<br>        <span class="hljs-built_in">front</span>(); 返回队头元素<br>        <span class="hljs-built_in">back</span>(); 返回队尾元素<br>        <span class="hljs-built_in">pop</span>(); 把队头弹出<br>        注意：队列没有clear函数！！！<br>    清空：<br>        变量名 = queue &lt;<span class="hljs-type">int</span>&gt; ();<br>priority_queue（优先队列，堆）<br>    注意：默认是大根堆！！！<br>    定义：：<br>        大根堆：priority_queue &lt;类型&gt; 变量名;<br>        小根堆：priority_queue &lt;类型,vecotr &lt;类型&gt;,greater &lt;类型&gt;&gt; 变量名<br>    常用函数：<br>        <span class="hljs-built_in">size</span>(); 这个堆的长度<br>        <span class="hljs-built_in">empty</span>(); 返回这个堆是否为空<br>        <span class="hljs-built_in">push</span>();往堆里插入一个元素<br>        <span class="hljs-built_in">top</span>(); 返回堆顶元素<br>        <span class="hljs-built_in">pop</span>(); 弹出堆顶元素<br>        注意：堆没有clear函数！！！<br><br>stack（栈）<br>    常用函数：<br>        <span class="hljs-built_in">size</span>(); 这个栈的长度<br>        <span class="hljs-built_in">empty</span>(); 返回这个栈是否为空<br>        <span class="hljs-built_in">push</span>(); 向栈顶插入一个元素<br>        <span class="hljs-built_in">top</span>(); 返回栈顶元素<br>        <span class="hljs-built_in">pop</span>(); 弹出栈顶元素<br><br>deque（双端队列）<br>    常用函数：<br>        <span class="hljs-built_in">size</span>(); 这个双端队列的长度<br>        <span class="hljs-built_in">empty</span>(); 返回这个双端队列是否为空<br>        <span class="hljs-built_in">clear</span>(); 清空这个双端队列<br>        <span class="hljs-built_in">front</span>(); 返回第一个元素<br>        <span class="hljs-built_in">back</span>(); 返回最后一个元素<br>        <span class="hljs-built_in">push_back</span>(); 向最后插入一个元素<br>        <span class="hljs-built_in">pop_back</span>(); 弹出最后一个元素<br>        <span class="hljs-built_in">push_front</span>(); 向队首插入一个元素<br>        <span class="hljs-built_in">pop_front</span>(); 弹出第一个元素<br>        <span class="hljs-built_in">begin</span>(); 双端队列的第<span class="hljs-number">0</span>个数<br>        <span class="hljs-built_in">end</span>(); 双端队列的最后一个的数的后面一个数<br><br>set，map，multiset，multimap 基于平衡二叉树（红黑树），动态维护有序序列<br>    set/multiset<br>        注意：set不允许元素重复，如果有重复就会被忽略，但multiset允许！！！<br>        常用函数：<br>            <span class="hljs-built_in">size</span>(); 返回元素个数<br>            <span class="hljs-built_in">empty</span>(); 返回set是否是空的<br>            <span class="hljs-built_in">clear</span>(); 清空<br>            <span class="hljs-built_in">begin</span>(); 第<span class="hljs-number">0</span>个数，支持++或--，返回前驱和后继<br>            <span class="hljs-built_in">end</span>(); 最后一个的数的后面一个数，支持++或--，返回前驱和后继<br>            <span class="hljs-built_in">insert</span>(); 插入一个数<br>            <span class="hljs-built_in">find</span>(); 查找一个数<br>            <span class="hljs-built_in">count</span>(); 返回某一个数的个数<br>            <span class="hljs-built_in">erase</span>();<br>                （<span class="hljs-number">1</span>）输入是一个数x，删除所有<span class="hljs-function">x    <span class="hljs-title">O</span><span class="hljs-params">(k + log n)</span></span><br><span class="hljs-function">                （2）输入一个迭代器，删除这个迭代器</span><br><span class="hljs-function">            <span class="hljs-title">lower_bound</span><span class="hljs-params">(x)</span></span>; 返回大于等于x的最小的数的迭代器<br>            <span class="hljs-built_in">upper_bound</span>(x); 返回大于x的最小的数的迭代器<br>    map/multimap<br>        常用函数：<br>            <span class="hljs-built_in">insert</span>(); 插入一个数，插入的数是一个<span class="hljs-function">pair</span><br><span class="hljs-function">            <span class="hljs-title">erase</span><span class="hljs-params">()</span></span>; <br>                （<span class="hljs-number">1</span>）输入是pair<br>                （<span class="hljs-number">2</span>）输入一个迭代器，删除这个迭代器<br>            <span class="hljs-built_in">find</span>(); 查找一个数<br>            <span class="hljs-built_in">lower_bound</span>(x); 返回大于等于x的最小的数的迭代器<br>            <span class="hljs-built_in">upper_bound</span>(x); 返回大于x的最小的数的迭代器<br><br>unordered_set，unordered_map，unordered_muliset,unordered_multimap 基于哈希表<br>    和上面类似，增删改查的时间复杂度是<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>    不支持<span class="hljs-built_in">lower_bound</span>()和<span class="hljs-built_in">upper_bound</span>()<br><br>bitset 压位<br>    定义：<br>        bitset &lt;个数&gt; 变量名;<br>    支持：<br>        ~，&amp;，|，^<br>        &gt;&gt;，&lt;&lt;<br>        ==，!=<br>        []<br>    常用函数：<br>        <span class="hljs-built_in">count</span>(); 返回某一个数的个数<br>        <span class="hljs-built_in">any</span>(); 判断是否至少有一个<span class="hljs-number">1</span><br>        <span class="hljs-built_in">none</span>(); 判断是否全为<span class="hljs-number">0</span><br>        <span class="hljs-built_in">set</span>(); 把所有位置赋值为<span class="hljs-number">1</span><br>        <span class="hljs-built_in">set</span>(k,v); 将第k位变成<span class="hljs-function">v</span><br><span class="hljs-function">        <span class="hljs-title">reset</span><span class="hljs-params">()</span></span>; 把所有位变成<span class="hljs-number">0</span><br>        <span class="hljs-built_in">flip</span>(); 把所有位取反，等价于~<br>        <span class="hljs-built_in">flip</span>(k); 把第k位取反<br></code></pre></td></tr></table></figure><h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><p><strong>pair将一对值(T1和T2)组合成一个值</strong>，</p><p><em><strong>这一对值可以具有</strong></em><em><strong>不同的</strong></em><em><strong>数据类型（T1和T2）</strong></em>，</p><p><em><strong>必须提供两个类型名，两个对应的类型名的类型不必相同</strong></em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;string, string&gt; anon;        <span class="hljs-comment">// 创建一个空对象anon，两个元素类型都是string</span><br>pair&lt;string, <span class="hljs-type">int</span>&gt; word_count;     <span class="hljs-comment">// 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span><br>pair&lt;string, vector&lt;<span class="hljs-type">int</span>&gt; &gt; line;  <span class="hljs-comment">// 创建一个空对象line，两个元素类型分别是string和vector类型</span><br></code></pre></td></tr></table></figure><p>两个值可以分别<strong>用pair的两个公有函数first和second访问</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;T1, T2&gt; p1;            <span class="hljs-comment">//创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。</span><br><span class="hljs-function">pair&lt;T1, T2&gt; <span class="hljs-title">p1</span><span class="hljs-params">(v1, v2)</span></span>;    <span class="hljs-comment">//创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2。</span><br><span class="hljs-built_in">make_pair</span>(v1, v2);          <span class="hljs-comment">// 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。</span><br>p1 &lt; p2;                    <span class="hljs-comment">// 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true。</span><br>p1 == p2；                  <span class="hljs-comment">// 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。</span><br>p1.first;                   <span class="hljs-comment">// 返回对象p1中名为first的公有数据成员</span><br>p1.second;                 <span class="hljs-comment">// 返回对象p1中名为second的公有数据成员</span><br></code></pre></td></tr></table></figure><h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>auto 会自动识别b的类别</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>&#123;<br>  arr[i]=i;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;a:arr)  <span class="hljs-comment">//   for(auto a:arr)  没有&amp;是一样的</span><br>&#123;<br>  cout &lt;&lt; a;<br>&#125;<br> <span class="hljs-comment">/*上面的for循环</span><br><span class="hljs-comment"> for(int i=0;i&lt;10;i++)&#123;</span><br><span class="hljs-comment">    cout&lt;&lt;arr[i];</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="/img/Photo/C++/01.png"></p><h2 id="for-auto-amp-c-s-与for-auto-c-s"><a href="#for-auto-amp-c-s-与for-auto-c-s" class="headerlink" title="for(auto &amp;c:s)与for(auto c:s)"></a>for(auto &amp;c:s)与for(auto c:s)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-function">string  <span class="hljs-title">s</span><span class="hljs-params">( <span class="hljs-string">&quot;hello world&quot;</span> )</span></span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c:s)<br>     c= <span class="hljs-string">&#x27;t&#x27;</span> ;<br>     cout&lt;&lt;s&lt;&lt;endl; <span class="hljs-comment">//结果为hello world</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c:s)<br>     c= <span class="hljs-string">&#x27;t&#x27;</span> ;<br>     cout&lt;&lt;s&lt;&lt;endl; <span class="hljs-comment">//结果为ttttttttttt</span><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>区别在于<strong>引用类型</strong>可以<strong>改变</strong>原来的值</p><p> 在进行遍历操作时,不加&amp;的c:s,会复制一个s字符串。用&amp;c:s时，是<strong>直接引用</strong>原字符串进行遍历操作。  </p><h1 id="sstream"><a href="#sstream" class="headerlink" title="sstream"></a>sstream</h1><h2 id="string转int"><a href="#string转int" class="headerlink" title="string转int"></a>string转int</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sstream&gt;</span></span><br><br>string s;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-built_in">getline</span>(cin,s);<br><br>stringstream sstream;<br><br>sstream&lt;&lt;s;<br><br><span class="hljs-keyword">while</span>(sstream&gt;&gt;a[n]) n++;<br></code></pre></td></tr></table></figure><h2 id="int转string"><a href="#int转string" class="headerlink" title="int转string"></a>int转string</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sstream&gt;</span></span><br><br>string s;<br><span class="hljs-type">int</span> n;<br><br>stringstream sstream;<br><br>cin&gt;&gt;n;<br><br>sstream&lt;&lt;n;<br><br>sstream&gt;&gt;s;<br></code></pre></td></tr></table></figure><h1 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h1><p>位移运算符有两种，左移运算符  &lt;&lt;  和  右移运算符  &gt;&gt;</p><p>箭头指向哪，就是往哪移；</p><h2 id="左移运算符-lt-lt"><a href="#左移运算符-lt-lt" class="headerlink" title="左移运算符  &lt;&lt;"></a>左移运算符  &lt;&lt;</h2><p>将一个数的各二进制位全部左移若干位，右补0；高位左移后溢出，舍弃；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">3</span>&lt;&lt;<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p> 是将数字3左移2位。即00000011—–&gt;00001100；</p><p>a的结果就是12；</p><h2 id="右移运算符-lt-lt"><a href="#右移运算符-lt-lt" class="headerlink" title="右移运算符  &lt;&lt;"></a>右移运算符  &lt;&lt;</h2><p>将一个数的各二进制位全部右移若干位， 高位的空位补符号位，即正数补0，负数补1；低位右移后溢出，舍弃；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> b = <span class="hljs-number">11</span> &gt;&gt; <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p> 是将数字11右移2位，即00001011——&gt;00000010；</p><p>b的结果就是2；</p><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>对于二进制的左移或者右移，那么就有一个很巧妙的用法了；</p><p>对1进行左移可以用来表示2的几次方；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> c =<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>; <span class="hljs-comment">// 2的2次方；00000001------&gt;00000100；</span><br><span class="hljs-type">int</span> d =<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>; <span class="hljs-comment">// 2的4次方；00000001------&gt;00010000；</span><br></code></pre></td></tr></table></figure><h1 id="运算符-x3D-、-amp-x3D-、-x3D"><a href="#运算符-x3D-、-amp-x3D-、-x3D" class="headerlink" title="运算符 |&#x3D;、&amp;&#x3D;、^&#x3D;"></a>运算符 |&#x3D;、&amp;&#x3D;、^&#x3D;</h1><h2 id="x3D-位异或"><a href="#x3D-位异或" class="headerlink" title="^&#x3D;位异或"></a>^&#x3D;位异或</h2><p>a^&#x3D;b<em><strong>等价于a &#x3D; a^b</strong></em>，其中^是<strong>位异或</strong>运算，即将a与b的对应位进行<strong>异或运算</strong>，<strong>同为0或者同为1时</strong>，对应位结果为0；否则为1。</p><p>假设，a的值为二进制的1010，b的值为二进制的1100，那么a^b &#x3D; 0110。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>; <span class="hljs-comment">// 0000 0101</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>; <span class="hljs-comment">// 0000 0011</span><br>a ^= b; <span class="hljs-comment">// 0000 0110</span><br></code></pre></td></tr></table></figure><h2 id="x3D"><a href="#x3D" class="headerlink" title="|&#x3D;"></a>|&#x3D;</h2><p> 两个二进制对应位为0时该位为0，否则为1 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>; <span class="hljs-comment">// 0000 0101</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>; <span class="hljs-comment">// 0000 0011</span><br>a |= b; <span class="hljs-comment">// 0000 0111</span><br></code></pre></td></tr></table></figure><h2 id="amp-x3D"><a href="#amp-x3D" class="headerlink" title="&amp;&#x3D;"></a>&amp;&#x3D;</h2><p> 两个二进制对应位都为1时，结果为1，否则结果为都0。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>; <span class="hljs-comment">// 0000 0101</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">3</span>; <span class="hljs-comment">// 0000 0011</span><br>a &amp;= b; <span class="hljs-comment">// 0000 0001</span><br></code></pre></td></tr></table></figure><h2 id="秦九韶算法"><a href="#秦九韶算法" class="headerlink" title="秦九韶算法"></a>秦九韶算法</h2><p>讲几个n进制的数转换成十进制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> b)</span> <span class="hljs-comment">//将b进制的数转化成十进制</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//秦九韶算法</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c: s)<br>        res = res * b +c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">10</span>进制转换成<span class="hljs-number">16</span>进制<br><span class="hljs-keyword">while</span>(c!=<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">int</span> t = c%<span class="hljs-number">16</span>;<br>c/=<span class="hljs-number">16</span>;<br>a[++m]=t;<br>&#125;<br><span class="hljs-keyword">while</span>(c!=<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">int</span> t = c%<span class="hljs-number">16</span>;<br>c/=<span class="hljs-number">16</span>;<br>a[++m]=t;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="以二进制为例"><a href="#以二进制为例" class="headerlink" title="以二进制为例"></a>以二进制为例</h3><p>s &#x3D; 10101;</p><p>b &#x3D; 2;</p><p><img src="/img/Photo/C++/02.jpeg"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯模板</title>
    <link href="/2022/04/01/Algorithm/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/04/01/Algorithm/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>本篇文章只是基础部分，分为基础算法和基础数论</p><h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><ol><li>二分的本质并不是单调性，有单调可以用二分，用二分不一定得是单调；</li><li>二分的本质是条件和边界；</li><li>关于要不要加1，就看是l&#x3D;mid还是r&#x3D;mid；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h3><p><strong>注意</strong></p><ol><li>eps的值要比题目中的小数位多2位</li><li>要注意边界和范围，比如0.01的三次方根</li></ol><p>可以让l&#x3D;-10000和r&#x3D;10000</p><p>或者分正负两种情况，让一个的边界去max（1.0，n）或者max（-1.0，n）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><p>两者之间的关系： a[n] &#x3D; b[1]+b[2]+b[3]+……b[n];</p><p>a[n]是前缀和；</p><p>b[n]是差分；</p><p>tip : 两个数组本没有时时联动关系，对某一数组操作以后需要通过手动操作同步</p><p>在题目中，前缀和  就是  根据a[n] 构造一个 其前n项和 a[n] ;</p><p>差分  是  构造一个b[n] 让a[n] 是他的前n项和 ;</p><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>类似数列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]；<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]；<br><br><span class="hljs-comment">//最最重要的是思想</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>S[i] = S[i<span class="hljs-number">-1</span>]+a[i];<br>    <span class="hljs-comment">//每个i都有其对应的前缀和</span><br></code></pre></td></tr></table></figure><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>差分就一个思想 <strong>插入</strong></p><p><strong>给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l]+=c;<br>    b[r+<span class="hljs-number">1</span>]-=c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">insert</span>(i,i,a[i]);<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);<br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        sum+=b[i];<br>        a[i]=sum;<br>       <span class="hljs-comment">//b[i]+=b[i-1];</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">求n的第k位数字: n &gt;&gt; k &amp; <span class="hljs-number">1</span><br>返回n的最后一位<span class="hljs-number">1</span>：<span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br></code></pre></td></tr></table></figure><p>n的二进制表示中第k位是几（从个位算）</p><p>先把第k位移到最后一位  用右移 &gt;&gt;</p><p>看个位是几 n&gt;&gt;k &amp; 1;</p><p>1的话是0000 0001</p><p>除了最后一位，前面全是0，所以可以看出来最后一位是什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n=<span class="hljs-number">10</span>;<br>cout&lt;&lt;(n&gt;&gt;<span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br><span class="hljs-comment">//输出是1，因为10的二进制是1010，右移一位后变成101；</span><br><span class="hljs-comment">//&amp;是  同为1才为1</span><br></code></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// st[u] 表示点u已经被遍历过</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j]) <span class="hljs-built_in">dfs</span>(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示1号点已经被遍历过</span><br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>&#123;<br>    <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示点j已经被遍历过</span><br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a><a href="https://www.cnblogs.com/xss9/p/16037334.html">最短路</a></h2><h1 id="基础数论"><a href="#基础数论" class="headerlink" title="基础数论"></a>基础数论</h1><h2 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (st[i]) <span class="hljs-keyword">continue</span>;<br>        primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i)<br>            st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="质数筛（线性筛法）"><a href="#质数筛（线性筛法）" class="headerlink" title="质数筛（线性筛法）"></a>质数筛（线性筛法）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> primes[N], cnt;     <span class="hljs-comment">// primes[]存储所有素数</span><br><span class="hljs-type">bool</span> st[N];         <span class="hljs-comment">// st[x]存储x是否被筛掉</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最大公约数（欧几里得算法）"><a href="#最大公约数（欧几里得算法）" class="headerlink" title="最大公约数（欧几里得算法）"></a>最大公约数（欧几里得算法）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">求 m^k mod p，时间复杂度 <span class="hljs-built_in">O</span>(logk)。<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span> % p, t = m;<br>    <span class="hljs-keyword">while</span> (k)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (k&amp;<span class="hljs-number">1</span>) res = res * t % p;<br>        t = t * t % p;<br>        k &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tips</title>
    <link href="/2022/03/26/Algorithm/Tips/"/>
    <url>/2022/03/26/Algorithm/Tips/</url>
    
    <content type="html"><![CDATA[<h1 id="蔡勒公式：随便给一个日期，直接算出是星期几。"><a href="#蔡勒公式：随便给一个日期，直接算出是星期几。" class="headerlink" title="蔡勒公式：随便给一个日期，直接算出是星期几。"></a>蔡勒公式：随便给一个日期，直接算出是星期几。</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">w</span>=y+⌊y/<span class="hljs-number">4</span>⌋+⌊c/<span class="hljs-number">4</span>⌋−<span class="hljs-number">2</span>c+⌊<span class="hljs-number">26</span>(m+<span class="hljs-number">1</span>)/<span class="hljs-number">10</span>⌋+d−<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>w为星期，c为世纪的前两位，y为年后两位，m为月，d为日。</p><p>其中m大于等于3，小于等于14，某年的1,2月要看成上一年的十三月，十四月来计算。</p><p>蔡勒公式甚至还能算到公元前，比如公元前1世纪，就令c&#x3D;-1，以此类推。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">zeller</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>, m = <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (month == <span class="hljs-number">1</span> || month == <span class="hljs-number">2</span> )<br>    &#123;<br>        c = (year - <span class="hljs-number">1</span>) / <span class="hljs-number">100</span>;<br>        y = (year - <span class="hljs-number">1</span>) % <span class="hljs-number">100</span>;<br>        m = month + <span class="hljs-number">12</span>;<br>        d = day;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        c = year / <span class="hljs-number">100</span>;<br>        y = year % <span class="hljs-number">100</span>;<br>        m = month;<br>        d = day;<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = y + y / <span class="hljs-number">4</span> + c / <span class="hljs-number">4</span> - <span class="hljs-number">2</span> * c + <span class="hljs-number">26</span> * (m + <span class="hljs-number">1</span>) / <span class="hljs-number">10</span> + d - <span class="hljs-number">1</span>; <span class="hljs-comment">//蔡勒公式</span><br>    res = (res + <span class="hljs-number">7</span>) % <span class="hljs-number">7</span>; <span class="hljs-comment">//防止出现负的</span><br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快读"><a href="#快读" class="headerlink" title="快读"></a>快读</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-keyword">do</span>&#123;<br>        ch=<span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)<br>            f=<span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">while</span>(ch&gt;‘<span class="hljs-number">9</span>’||ch&lt;‘<span class="hljs-number">0</span>’);<br><br>    <span class="hljs-keyword">do</span>&#123;<br>        x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        ch=<span class="hljs-built_in">getchar</span>();<br>    &#125;<span class="hljs-keyword">while</span>(ch&lt;=‘<span class="hljs-number">9</span>’&amp;&amp;ch&gt;=‘<span class="hljs-number">0</span>’);<br><br>    <span class="hljs-keyword">return</span> f*x;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆向思路</title>
    <link href="/2022/03/10/Algorithm/%E9%80%86%E5%90%91%E6%80%9D%E8%B7%AF/"/>
    <url>/2022/03/10/Algorithm/%E9%80%86%E5%90%91%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>当我们遇到一道算法题，有时候从正面解决问题很困难，或者根本不能解决问题，那么这时候既可以从反面来思考；</p><p>只是通过文字说明是不行的，来看两道例题，让我们锻炼一下自己的思维；</p><h1 id="T1：滑雪场设计"><a href="#T1：滑雪场设计" class="headerlink" title="T1：滑雪场设计"></a>T1：滑雪场设计</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="/img/Photo/Reverse/01.png"><br><img src="/img/Photo/Reverse/02.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><em>开始准备用贪心来做，后来发现山峰的高度变换后，可能导致一系列问题，比如最高峰和最低峰变成了其他山峰，因为有后效性，所以无法直接使用贪心。</em></p><p>换一种思路：</p><p>修改后，任意两个山峰之间距离不大于17;<strong>也就是最大值与最小值的差为17;</strong></p><p>每座山的初始高度都在 0∼100 之间，如果修改后最低的山峰为0的话，最高的山峰就是17，如果修改后最低的山峰为50的话，最高的山峰就是57；</p><p>修改后，最低的山峰的范围为0<del>83，对应最高的山峰为17</del>100；</p><p>因此我们<strong>只需要枚举这83种情况</strong>，比最低峰小的话就加上，比最高峰大的话就减去；</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;h[i]; <span class="hljs-comment">//输入</span><br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">1e8</span>; <br>    <span class="hljs-comment">//枚举83种情况，比最低峰小的话就加上，比最高峰大的话就减去；</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">83</span>;i++) <span class="hljs-comment">//枚举83种情况</span><br>    &#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(h[j]&lt;i) res+=<span class="hljs-built_in">pow</span>(i-h[j],<span class="hljs-number">2</span>); <span class="hljs-comment">//小于最低峰</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(h[j]&gt;i+<span class="hljs-number">17</span>) res+=<span class="hljs-built_in">pow</span>(h[j]-i<span class="hljs-number">-17</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//大于最高峰</span><br>        &#125;<br>        ans=<span class="hljs-built_in">min</span>(res,ans); <span class="hljs-comment">//找到最小的差值</span><br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="T2：里程表"><a href="#T2：里程表" class="headerlink" title="T2：里程表"></a>T2：里程表</h1><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="/img/Photo/Reverse/03.png"><br><img src="/img/Photo/Reverse/04.png"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>一看这道题数据范围大的快上天了，哪怕把所有的数字循环一次都会TLE。</p><p>并不难，就是在于逆向思维。</p><p>我们就可以换一个角度想，<strong>因为“有趣的数”并不多，所以我们可以先枚举出每一个“有趣的数”</strong>，最后判断区间(x,y)(x,y)之间有几个“有趣的数”即可。</p><p>枚举的层次：</p><p>数字长度-&gt;构造一个各位全部相同的数字-&gt;新的数字k，判重并改字符-&gt;统计答案</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//预处理出来所有的有趣的数字</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> x,y,ans; <span class="hljs-comment">//不开long long见祖宗</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;x&gt;&gt;y;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-number">17</span>;i++) <span class="hljs-comment">//i表示数字的长度</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">9</span>;j++) <span class="hljs-comment">//相同的数字</span><br>        &#123;<br>            <span class="hljs-comment">//构造一个字符串strstr，长度为i，并且把每一位都赋值为j这个数</span><br>            <span class="hljs-comment">//但是在这里要转化为字符形式</span><br>            <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(i, <span class="hljs-string">&#x27;0&#x27;</span> +j)</span></span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">9</span>;k++) <span class="hljs-comment">//不同的数字</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(k==j) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//判重</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;p&lt;i;p++)<br>                &#123;<br>                    str[p]=<span class="hljs-string">&#x27;0&#x27;</span>+k; <span class="hljs-comment">//有趣的数字</span><br>                    <span class="hljs-comment">//再转换成number</span><br>                    <span class="hljs-type">long</span> <span class="hljs-type">long</span> t=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> q=<span class="hljs-number">0</span>;q&lt;i;q++) t=t*<span class="hljs-number">10</span>+(str[q]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>                    <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>]! =<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;t&gt;=x&amp;&amp;t&lt;=y) ans++;<br>                    str[p]=<span class="hljs-string">&#x27;0&#x27;</span>+j; <span class="hljs-comment">//还原现场,进行下一次循环</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路</title>
    <link href="/2022/02/22/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <url>/2022/02/22/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/Photo/ShortestRoute/01.jpeg"></p><p><em><strong>最短路难点不在于证明，在于建图，把一个问题抽象成图，如何定义边，如何定义图</strong></em></p><h1 id="Dijkstra迪杰斯特拉"><a href="#Dijkstra迪杰斯特拉" class="headerlink" title="Dijkstra迪杰斯特拉"></a>Dijkstra迪杰斯特拉</h1><p>本质，是不断刷新起点与其他各个顶点之间的 “距离表”。</p><ol><li>初始化距离<br>一号结点的距离为零，其他结点的距离设为无穷大（看具体的题）。</li><li>循环n次，每一次将集合S之外距离最短X的点加入到S中去（这里的距离最短指的是距离1号点最近。点X的路径一定最短，基于贪心，严格证明待看）。然后用点X更新X邻接点的距离。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> g[N][N];  <span class="hljs-comment">// 存储每条边</span><br><span class="hljs-type">int</span> dist[N];  <span class="hljs-comment">// 存储1号点到每个点的最短距离</span><br><span class="hljs-type">bool</span> st[N];   <span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist); <span class="hljs-comment">//初始化，一开始都是无限大</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ ) <span class="hljs-comment">// 循环n-1次，每个号都遍历一次(除了最后一个n)</span><br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 在还未确定最短路的点中，寻找距离最小的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;  <span class="hljs-comment">// 得到距离最近的一个号</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);  <span class="hljs-comment">// 用t更新其他点的最短距离</span><br>        <br>        st[t] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//进行标记，下次不取这个号</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆优化版Dijkstra-适合稀疏图"><a href="#堆优化版Dijkstra-适合稀疏图" class="headerlink" title="堆优化版Dijkstra(适合稀疏图)"></a>堆优化版Dijkstra(适合稀疏图)</h1><p><strong>堆优化版的dijkstra是对朴素版dijkstra进行了优化，在朴素版dijkstra中时间复杂度最高的寻找距离最短的点O(n^2)可以使用最小堆优化。</strong></p><ol><li>一号点的距离初始化为零，其他点初始化成无穷大。</li><li>将一号点放入堆中。</li><li>不断循环，直到堆空。每一次循环中执行的操作为：<br>弹出堆顶（与朴素版diijkstra找到S外距离最短的点相同，并标记该点的最短路径已经确定）。<br>用该点更新临界点的距离，若更新成功就加入到堆中。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 点的数量</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储所有点到1号点的距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点的最短距离是否已确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">// first存储距离，second存储节点编号</span><br><br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman - ford"></a>bellman - ford</h1><h2 id="ACwing算法分析-必看-）"><a href="#ACwing算法分析-必看-）" class="headerlink" title="ACwing算法分析(必看~~）"></a><a href="https://www.acwing.com/solution/content/6320/">ACwing算法分析</a>(必看~~）</h2><p><img src="/img/Photo/ShortestRoute/02.png"><br><img src="/img/Photo/ShortestRoute/03.png"><br><img src="/img/Photo/ShortestRoute/04.png"><br><img src="/img/Photo/ShortestRoute/05.png"></p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p><strong>用结构体储存，方便遍历所有边。</strong></p><p><code>**bellman-ford**</code><strong>算法关注的是快速遍历每一条边，邻接表是以点出发，这些点关联了那些边，如果点非常多，边非常少的话，用邻接表遍历到每一条边就麻烦了，且性能差，不如直接记录边的结构体来的快</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n表示点数，m表示边数</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// dist[x]存储1到x的最短路距离</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 边，a表示出点，b表示入点，w表示边的权重</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>&#125;edges[M];<br><br><span class="hljs-comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-comment">//一共走n步数</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>            <span class="hljs-keyword">if</span> (dist[b] &gt; dist[a] + w)<br>                dist[b] = dist[a] + w;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h1><p><code>bellman-ford</code>算法很傻，在该算法中，我们需要遍历很多次所有的边，在遍历的过程中，只有满足<code>dist[b] &gt; dist[a] + w</code>这个条件，距离才会发生改变。<code>SPFA</code>算法进行了改进，只有<code>dist[a]</code>发生变化，才遍历和他相关的边。</p><p><code>bellman_ford</code>算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，<strong>我们将创建一个队列每一次加入距离被更新的结点。</strong></p><h2 id="值得注意的是-记得看！-大佬题解"><a href="#值得注意的是-记得看！-大佬题解" class="headerlink" title="值得注意的是  记得看！~(大佬题解)"></a><a href="https://www.acwing.com/solution/content/9306/">值得注意的是</a>  记得看！~(大佬题解)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储每个点到1号点的最短距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<span class="hljs-comment">//初始化很重要</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//不要忘记初始化</span><br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//出队后记得恢复</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-comment">//这里判断dist[j]是否发生变化，变化了才可以入队，不能用min</span><br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i]) <br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-comment">//只有j的距离变化了，才可以入队，故不可写在外面</span><br>                <span class="hljs-keyword">if</span> (!st[j])     <span class="hljs-comment">// 如果队列中已存在j，则不需要将j重复插入</span><br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SPFA判断负环"><a href="#SPFA判断负环" class="headerlink" title="SPFA判断负环"></a>SPFA判断负环</h1><p><em>就是在原有的</em><code>spfa</code><em>模板上加个</em><code>cnt[N]</code><em>用来记录每个点的边数</em></p><p><em>如果这个边数超过n个，那么一定存在负环</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N], cnt[N];<br><span class="hljs-comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 如果存在负环，则返回true，否则返回false。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 不需要初始化dist数组</span><br><span class="hljs-comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点</span><br>    <span class="hljs-comment">//由抽屉原理一定有两个点相同，所以存在环。</span><br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-comment">//这里要把所有的点入队，可能有单个的负环</span><br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span><br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="spfa、bellman-ford和djikstra三者的区别"><a href="#spfa、bellman-ford和djikstra三者的区别" class="headerlink" title="spfa、bellman-ford和djikstra三者的区别"></a>spfa、bellman-ford和djikstra三者的区别</h1><p><strong>首先，三者都是用来求最短路，但是思想和复杂度不相同。</strong></p><h2 id="bellman-ford-和spfa的区别"><a href="#bellman-ford-和spfa的区别" class="headerlink" title="bellman-ford 和spfa的区别"></a>bellman-ford 和spfa的区别</h2><p><em>1.</em><code>*Bellman-ford*</code><em>算法中，循环n次，每次遍历m条边，每次遍历的时候，把入度的点的距离更新成最小。</em></p><p><em>然而，这样就循环遍历了很多用不到的边。比如第一次遍历，只有第一个点的临边是有效的。</em></p><p><em>2.因此，</em><code>*spfa*</code><em>算法中，采用邻接表的方式，只用到有效的点（更新了临边的点），直到每个点都是最短距离为止。采用队列优化的方式存储每次更新了的点，每条边最多遍历一次。如果存在负权回路，从起点1出发，回到1距离会变小， 会一直在三个点中循环。</em></p><p><strong>Question:</strong></p><p>不用队列，遍历所有的点可以吗？</p><p><strong>Ans:</strong></p><p>似乎不行，因为是更新了点之后，这个点的临边才可以用，如果没有更新到循环的点，那么循环的点也是不可用的。</p><h2 id="spfa和dijkstra的区别："><a href="#spfa和dijkstra的区别：" class="headerlink" title="spfa和dijkstra的区别："></a>spfa和dijkstra的区别：</h2><p><code>*st*</code><em>用来检验队列中是否有重复的点</em></p><p><code>*spfa*</code><em>从队列中使用了当前的点，会把该点</em><code>*pop*</code><em>掉，状态数组</em><code>*st[i] = false*</code><em>(说明堆中不存在了) ，更新临边之后，把临边放入队列中， 并且设置状态数组为true，表示放入队列中 。如果当前的点距离变小，可能会再次进入队列，因此可以检验负环：</em></p><p>​    <em>每次更新可以记录一次，如果记录的次数 &gt; n,代表存在负环（环一定是负的，因为只有负环才会不断循环下去）。</em></p><p><code>*st*</code><em>是一个集合，不是检验队列中的点。</em></p><p><code>*dijkstra*</code><em>使用当前点更新临边之后，把该点加入到一个集合中，使用该点更新临边，并把临边节点和距离起点的距离置入堆中（不设置状态数组）。下一次从堆中取最小值，并把对应的节点放入集合中，继续更新临边节点，直到所有的点都存入集合中。因此</em><code>*dijkstra*</code><em>不判断负环。</em></p><p><em>从上述描述中能看出，</em><code>*dijkstra*</code><em>存放节点的堆，具有单调性，而</em><code>*spfa*</code><em>的队列不需要具有单调性。</em></p><h1 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h1><p><em>用于：给定一个n个点m条边的有向图，图中可能存在重边和自环，边权可能为负数。</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">初始化：<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br><br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//从i出发，只经过k，到达j的距离</span><br>    <br>    <span class="hljs-comment">//以k为中继点，k是阶段</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ ) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/img/Photo/ShortestRoute/06.png"><br><img src="/img/Photo/ShortestRoute/07.png"></p>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP</title>
    <link href="/2022/02/21/KMP/"/>
    <url>/2022/02/21/KMP/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/21923021">知乎的讲解</a></p><h1 id="KMP模板"><a href="#KMP模板" class="headerlink" title="KMP模板"></a>KMP模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span><br>求模式串的Next数组：<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )<br>    <span class="hljs-comment">//这里的i，j不是双指针，j是最大长度</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    ne[i] = j;<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>    <span class="hljs-keyword">if</span> (j == m)<br>    &#123;<br>        j = ne[j];<br>        <span class="hljs-comment">// 匹配成功后的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2022/02/15/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2022/02/15/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>首先让我们从一道题目入手</p><p><img src="/img/Photo/TreeArray/01.png"><br>对于一个算法新手来说，可能只会想到<strong>暴力做法</strong></p><p>每次求范围都进行一次for循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">whilie</span>(m--)<br>&#123;<br>    cin&gt;&gt;l&gt;&gt;r;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=;i&lt;=r;i++) sum+=a[i];<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>思考一下暴力做法的时间复杂度，会发现是O(mn)，在极端的情况下是10的12次方，会超时</p><h1 id="这时候就是需要算法优化——前缀和算法"><a href="#这时候就是需要算法优化——前缀和算法" class="headerlink" title="这时候就是需要算法优化——前缀和算法"></a>这时候就是需要算法优化——前缀和算法</h1><p>我们可以把把a[N]看成是一个数列，求出每一位的前n项和s[N]。</p><p>之后当我们再求某个区间内的和时，就不需要再进行一次for循环。</p><p>直接用前r个数的和，减去前l个数的和，</p><p>得到的就是l与r之间数的和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]；<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]；<br><br><span class="hljs-comment">//最最重要的是思想</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>S[i] = S[i<span class="hljs-number">-1</span>]+a[i];<br>    <span class="hljs-comment">//每个i都有其对应的前缀和</span><br></code></pre></td></tr></table></figure><p><strong>什么是前缀和</strong></p><p>原数组: a[1], a[2], a[3], a[4], a[5], …, a[n]</p><p>前缀和 S[i]为数组的前 i项和</p><p>前缀和: S[i] &#x3D; a[1] + a[2] + a[3] + … + a[i]</p><p><strong>注意: 前缀和的下标一定要从 1开始, 避免进行下标的转换</strong></p><p>s[0] &#x3D; 0</p><p>s[1] &#x3D; s[0]+a[1]</p><p><strong>前缀和的作用</strong></p><p>快速求出元素组中某段区间的和</p><p>这时候我们要思考一个问题，在这个题目中，是根据原始的a[N]数组算出的前缀和，在之后的每次查询中，原数组a[N]和前缀和s[N]都没有发生变化。倘若我们改变原数组a[N]中某位数的值,我们又该如何求某段区间的和哪</p><h1 id="动态求连续区间和"><a href="#动态求连续区间和" class="headerlink" title="动态求连续区间和"></a>动态求连续区间和</h1><p><img src="/img/Photo/TreeArray/02.png"></p><p>我们可以用刚刚学的知识——前缀和</p><p>题目中a[N]每改变一次，我们就更新她的前缀和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<br>    <br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> k,a,b;<br>        cin&gt;&gt;k&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>        &#123;<br>            cout&lt;&lt;s[b]-s[a<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a;i&lt;=n;i++) s[i]+=b;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>再思考一下时间复杂度，和上一题的暴力枚举做法一样，O(mn),显然超时</p><p>那么，该怎么进行优化哪</p><p>根据经验，至少要把时间复杂度优化到nlogn；</p><p>在上面这段代码中，循环m次是不可能改变的，因为就是要进行m次询问嘛</p><p>要想下如何优化这部分代码，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a;i&lt;=n;i++) s[i]+=b;<br></code></pre></td></tr></table></figure><p>也就是优化前缀和</p><p>因此</p><p>伟大的Peter M. Fenwick想出了<strong>树状数组，</strong>用于高效计算数列的前缀和， 区间和。</p><p>树状数组可以解决的问题</p><p>可以解决大部分基于<strong>区间上的更新(单点修改）</strong>以及**求和问题（区间查询)**。</p><p><img src="/img/Photo/TreeArray/03.png"></p><p>如果非要一句话说明<strong>树状数组 ：****将一个前缀和划分成多个子序列的和</strong></p><p>按照Peter M. Fenwick的说法，正如所有的整数都可以表示成2的幂和，我们也可以把一串序列表示成一系列子序列的和。</p><p>采用这个想法，我们可<strong>将一个前缀和划分成多个子序列的和</strong>，而划分的方法与<strong>数的2的幂和</strong>具有极其相似的方式。</p><p><strong>C[i] &#x3D; A[i - 2k+1] + A[i - 2k+2] + … + A[i];</strong> </p><p> <strong>&#x2F;&#x2F;k为i的二进制中从最低位到高位连续零的长度</strong></p><p><img src="/img/Photo/TreeArray/04.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//返回x的最后一位1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-comment">//add(x,y):在x位置加上y，并将后面相关联的位置也加上y</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i+=<span class="hljs-built_in">lowbit</span>(i)) tr[i]+=y;<br>&#125;<br><br><span class="hljs-comment">//query(x):询问x的前缀和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i;i-=<span class="hljs-built_in">lowbit</span>(i)) res+=tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <br>    <span class="hljs-comment">//求初始树状数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">add</span>(i,a[i]);<br>    <br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> k,x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;k,&amp;x,&amp;y);<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) <br>        &#123;<br>            <span class="hljs-type">int</span> ans=<span class="hljs-built_in">query</span>(y)-<span class="hljs-built_in">query</span>(x<span class="hljs-number">-1</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(x,y);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trie数 (字典树)</title>
    <link href="/2022/02/12/Trie%E6%95%B0%20(%E5%AD%97%E5%85%B8%E6%A0%91)/"/>
    <url>/2022/02/12/Trie%E6%95%B0%20(%E5%AD%97%E5%85%B8%E6%A0%91)/</url>
    
    <content type="html"><![CDATA[<p><strong>用来快速存储和查找字符串集合的一种数据结构</strong></p><p><img src="/img/Photo/Trie/01.png"><br><img src="/img/Photo/Trie/02.png"></p><h1 id="插入操作模板"><a href="#插入操作模板" class="headerlink" title="插入操作模板"></a>插入操作模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;  <span class="hljs-comment">//类似指针，指向当前节点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">//将字母转化为数字</span><br>        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++idx;<br>        <span class="hljs-comment">//该节点不存在，创建节点,其值为下一个节点位置</span><br>        p = son[p][u];  <span class="hljs-comment">//使“p指针”指向下一个节点位置</span><br>    &#125;<br>    cnt[p]++;  <span class="hljs-comment">//结束时的标记，也是记录以此节点结束的字符串个数</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="查询操作模板"><a href="#查询操作模板" class="headerlink" title="查询操作模板"></a>查询操作模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//该节点不存在，即该字符串不存在</span><br>        p = son[p][u]; <br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];  <span class="hljs-comment">//返回字符串出现的次数</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最大异或对"><a href="#最大异或对" class="headerlink" title="最大异或对"></a>最大异或对</h1><p><em><strong>res +&#x3D; 1 &lt;&lt; i;</strong></em> </p><p><em><strong>利用异或，if判断成立的话这一位就是1</strong></em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">3100010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], son[M][<span class="hljs-number">2</span>], idx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>    <span class="hljs-type">int</span> u = x&gt;&gt;i &amp; <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++idx; <br>        p = son[p][u];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        <span class="hljs-type">int</span> s = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (son[p][!s])<br>        &#123;<br>            <span class="hljs-comment">//有两种求法，一种是根据树中二进制的每一位，把与x异或最大的数求出来； </span><br><span class="hljs-comment">//另一种就是直接求两者异或的结果，根据if判断，是否树中有和x的某一位相异； </span><br>res += <span class="hljs-number">1</span> &lt;&lt; i; <span class="hljs-comment">// 这里的res是最后的答案； </span><br><span class="hljs-comment">//利用异或，if判断成立的话这一位就是1</span><br>            p = son[p][!s];<br>        &#125;<br>        <span class="hljs-keyword">else</span> p = son[p][s];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>    <span class="hljs-comment">//这里是先把全部都插入 </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>        <span class="hljs-built_in">insert</span>(a[i]);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">search</span>(a[i]));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">3100010</span>;<br><span class="hljs-type">int</span> a[N],son[M][<span class="hljs-number">2</span>],idx=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>&#123;<br><span class="hljs-type">int</span> u = x&gt;&gt;i&amp;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(!son[p][u]) son[p][u] = ++idx;<br>p = son[p][u]; <br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">30</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>&#123;<br><span class="hljs-type">int</span> u = x&gt;&gt;i &amp; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(son[p][!u]) <br>&#123;<br>res += (!u) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i);<br>p = son[p][!u];<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>    res += (u) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,i);<br>    p = son[p][u];<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-built_in">insert</span>(a[i]);<br><span class="hljs-type">int</span> t = <span class="hljs-built_in">query</span>(a[i]);<br>res = <span class="hljs-built_in">max</span>(res,t^a[i]);<br>&#125;<br>cout&lt;&lt;res;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉堆</title>
    <link href="/2022/01/30/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <url>/2022/01/30/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉堆的概念与理解"><a href="#二叉堆的概念与理解" class="headerlink" title="二叉堆的概念与理解"></a>二叉堆的概念与理解</h1><p><strong>二叉堆</strong>是一种支持 <strong>插入,删除,查询</strong>最值 的数据结构.</p><p>是一颗满足堆性质的<strong>完全二叉树</strong>,树上的每个节点带有一个权值.</p><p>若树种任意一个节点的权值都大于等于其父结点的权值,则称该二叉树为”小根堆”,就是父节点最小.</p><p>若树种任意一个节点的权值都小于等于其父结点的权值,则称该二叉树为”大根堆”，就是父节点最大.</p><p>可以利用<strong>数组</strong>,采用<strong>层次序列储存方式</strong>,若父节点为n,则他的左儿子为 (2n) ,右儿子为 (2n+1);</p><p><img src="/img/Photo/BinaryHeap/01.png"></p><h1 id="用数组模拟堆的五种操作"><a href="#用数组模拟堆的五种操作" class="headerlink" title="用数组模拟堆的五种操作"></a>用数组模拟堆的五种操作</h1><p><img src="/img/Photo/BinaryHeap/02.png"></p><h1 id="i为什么从n-x2F-2开始down？"><a href="#i为什么从n-x2F-2开始down？" class="headerlink" title="i为什么从n&#x2F;2开始down？"></a>i为什么从n&#x2F;2开始down？</h1><p>首先要明确要进行down操作时必须满足左儿子和右儿子已经是个堆。</p><p>开始创建堆的时候，元素是随机插入的，所以不能从根节点开始down，而是要找到满足下面三个性质的结点：</p><ol><li><p>左右儿子满足堆的性质。</p></li><li><p>下标最大（因为要往上遍历）</p></li><li><p>不是叶结点（叶节点一定满足堆的性质）</p></li></ol><p>那这个点为什么是n&#x2F;2？看图。</p><p><img src="/img/Photo/BinaryHeap/03.png"></p><h1 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span><br><span class="hljs-comment">// ph[k]存储第k个插入的点在堆中的位置</span><br><span class="hljs-comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="hljs-type">int</span> h[N], ph[N], hp[N], size;<br><br><span class="hljs-comment">// 交换两个点，及其映射关系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<br>    <span class="hljs-built_in">swap</span>(hp[a], hp[b]);<br>    <span class="hljs-built_in">swap</span>(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, t);<br>        <span class="hljs-built_in">down</span>(t);<span class="hljs-comment">//这里down(t)是因为t所在的节点变化了;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// O(n)建堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i -- ) <span class="hljs-built_in">down</span>(i);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间求交</title>
    <link href="/2022/01/26/Algorithm/%E5%8C%BA%E9%97%B4%E6%B1%82%E4%BA%A4/"/>
    <url>/2022/01/26/Algorithm/%E5%8C%BA%E9%97%B4%E6%B1%82%E4%BA%A4/</url>
    
    <content type="html"><![CDATA[<p>在一个二维空间内，两个长方形之间的交集。</p><p><img src="/img/Photo/IntervalIntersect/01.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c,<span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">min</span>(b,d)-<span class="hljs-built_in">max</span>(a,c));<br>&#125;<br></code></pre></td></tr></table></figure><p>应用题目：<a href="https://www.acwing.com/problem/content/1763/">1761. 阻挡广告牌</a></p><p><img src="/img/Photo/IntervalIntersect/02.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c,<span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">min</span>(b,d)-<span class="hljs-built_in">max</span>(a,c));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (a[<span class="hljs-number">2</span>]-a[<span class="hljs-number">0</span>])*(a[<span class="hljs-number">3</span>]-a[<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++) cin&gt;&gt;a[i][j];<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>;i++)<br>        res+=<span class="hljs-built_in">get</span>(a[i][<span class="hljs-number">0</span>],a[i][<span class="hljs-number">2</span>],a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>],a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>])*<br>            <span class="hljs-built_in">get</span>(a[i][<span class="hljs-number">1</span>],a[i][<span class="hljs-number">3</span>],a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]);<br>    <br>    cout&lt;&lt;<span class="hljs-built_in">sum</span>(a[<span class="hljs-number">1</span>])+<span class="hljs-built_in">sum</span>(a[<span class="hljs-number">0</span>])-res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2022/01/21/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2022/01/21/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ol><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>每个集合用一颗树来表示。树根的编号就是整个集合的编号。每个节点储存他的父亲节点，p[x]表示x的父节点</p><p><em><strong>p[x]就表示x属于哪个集合。</strong></em></p><p><img src="/img/Photo/AndLookup/01.png"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>如何判断树根(祖宗集合）  ：if ( p[x] &#x3D;&#x3D; x ); </li><li>如何求x的集合编号 ： while ( p[x] !&#x3D; x )  x &#x3D; p[x];</li><li>如何合并两个集合 ：p[x] 是 x 的集合编号，p[y] 是 y 的集合编号 ，让p[x] &#x3D; y;</li></ol><h1 id="最最最重要"><a href="#最最最重要" class="headerlink" title="最最最重要"></a>最最最重要</h1><p>递归的含义就相当于你问你爸爸你的祖先是谁，你爸爸也不知道，爸爸就去问爷爷，然后你的爷爷也不知道，爷爷就去问你的太爷爷，你的太爷爷年纪太大了，啥也不记得，就去问你的祖先</p><p>这个时候注意，你的祖先是知道自己是谁的，所以x &#x3D;&#x3D;p[x]</p><p>p[x]中储存的是每个节点的父节点，一开始并不是树状的，而是一个个单独的节点，每个节点都是根节点，都有集合编号，然后通过不断的合并才形成的树状结构</p><p><strong>这个函数是并查集中最重要的部分，背过理解</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]); <span class="hljs-comment">//路径压缩</span><br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="1-朴素并查集"><a href="#1-朴素并查集" class="headerlink" title="(1)朴素并查集:"></a>(1)朴素并查集:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">朴素并查集：<br><br>    <span class="hljs-type">int</span> p[N]; <span class="hljs-comment">//存储每个点的祖宗节点</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><h2 id="2-维护size的并查集"><a href="#2-维护size的并查集" class="headerlink" title="(2)维护size的并查集:"></a>(2)维护size的并查集:</h2><p>size只有祖节点的有意义</p><p>要特别注意所有处理size的地方，都要“归根结底”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">维护size的并查集：<br><br>    <span class="hljs-type">int</span> p[N], size[N];<br>    <span class="hljs-comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        p[i] = i;<br>        size[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    size[<span class="hljs-built_in">find</span>(b)] += size[<span class="hljs-built_in">find</span>(a)];<br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><h2 id="3-维护到祖宗节点距离的并查集："><a href="#3-维护到祖宗节点距离的并查集：" class="headerlink" title="(3)维护到祖宗节点距离的并查集："></a>(3)维护到祖宗节点距离的并查集：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">维护到祖宗节点距离的并查集：<br><br>    <span class="hljs-type">int</span> p[N], d[N];<br>    <span class="hljs-comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span><br><br>    <span class="hljs-comment">// 返回x的祖宗节点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p[x] != x)<br>        &#123;<br>            <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>            d[x] += d[p[x]];<br>            p[x] = u;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p[x];<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        p[i] = i;<br>        d[i] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>    p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>    d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></td></tr></table></figure><h1 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h1><p><strong>题目描述：</strong></p><p><img src="/img/Photo/AndLookup/02.png" alt="题目"></p><p><em><strong>p[x]就表示x属于哪个集合。</strong></em></p><p><strong>code:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) <span class="hljs-comment">// 去找祖宗</span><br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(p[x]); <span class="hljs-comment">// 找到祖宗</span><br>        p[x] = t; <span class="hljs-comment">// 祖宗秒变爹   路径压缩 </span><br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];  <span class="hljs-comment">//返回的是节点的祖宗 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) p[i]=i;<br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">char</span> c;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;c&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;M&#x27;</span>) <br>        &#123;<br>            p[<span class="hljs-built_in">find</span>(a)]=<span class="hljs-built_in">find</span>(b); <span class="hljs-comment">//让a的祖宗都是b的，也就是说，让a的整个集合都属于b； </span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和与差分</title>
    <link href="/2022/01/16/Algorithm/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
    <url>/2022/01/16/Algorithm/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>两者之间的关系： a[n] &#x3D; b[1]+b[2]+b[3]+……b[n];</p><p>a[n]是前缀和；</p><p>b[n]是差分；</p><p>tip : 两个数组本没有时时联动关系，对某一数组操作以后需要通过手动操作同步</p><p><em><strong>考虑更新</strong></em></p><p>在题目中，前缀和  就是  根据a[n] 构造一个 其前n项和 a[n] ;</p><p>差分  是  构造一个b[n] 让a[n] 是他的前n项和 ;</p><h1 id="前缀和n"><a href="#前缀和n" class="headerlink" title="前缀和n"></a>前缀和n</h1><h2 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h2><p>类似数列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]；<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]；<br><br><span class="hljs-comment">//最最重要的是思想</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>S[i] = S[i<span class="hljs-number">-1</span>]+a[i];<br>    <span class="hljs-comment">//每个i都有其对应的前缀和</span><br></code></pre></td></tr></table></figure><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S[i, j] = 第i行j列格子左上部分所有元素的和;<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>  &#123;<br>    s[i][j] = s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>  &#125;<br></code></pre></td></tr></table></figure><p>一维</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]；<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]；<br><br><span class="hljs-comment">//最最重要的是思想</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>S[i] = S[i<span class="hljs-number">-1</span>]+a[i];<br>    <span class="hljs-comment">//每个i都有其对应的前缀和</span><br></code></pre></td></tr></table></figure><p>二维</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S[i, j] = 第i行j列格子左上部分所有元素的和;<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>  &#123;<br>    s[i][j] = s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>  &#125;<br></code></pre></td></tr></table></figure><p><img src="/img/Photo/PrefixAnd/01.png"><br><a href="https://www.acwing.com/problem/content/3959/">截断数组</a><br>将一个数组，分成三个子数组，使这三个子数组内的各个元素之和相等。<br>输出截断方法的数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//长度小于3时或者不足以分成三份时，为0</span><br>   <span class="hljs-keyword">if</span>(s[n<span class="hljs-number">-1</span>] % <span class="hljs-number">3</span> != <span class="hljs-number">0</span> || n &lt; <span class="hljs-number">3</span>)<br>   &#123;<br>       cout&lt;&lt;<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>   &#125;<br>   <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid = s[n<span class="hljs-number">-1</span>]/<span class="hljs-number">3</span>, sum = <span class="hljs-number">0</span>,t = <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">//计算方法，第一种的方法为t，那么出现第二种方法时，就加一次第一种的方法的数量t</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i ++)<br>   &#123;<br>       <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-number">2</span>*mid) sum += t;<br>       <span class="hljs-keyword">if</span>(s[i] == mid) t++;<br>   &#125;<br>   cout&lt;&lt;sum;<br></code></pre></td></tr></table></figure><p>k倍区间<br>一个数列，其中一段连续的子序列之和是k的倍数，就称为K倍区间<br>求数列中一共有多少个k倍区间</p><p>思路：可以用两层for循环，计算s[j] - s[i] 的值是否是k的倍数<br>但是这时时间复杂度是O(N^2)，会TimeOut<br>优化：<br>从数学公式的角度：<br>(s[j] - s[i]) % k &#x3D;&#x3D; 0;<br>这个公式可以拆开成为s[j]%k - s[i]%k &#x3D;&#x3D; 0;<br>开一个新的数组cnt[N]，cnt[i]表示在0~i之间的s[i]%k的个数，在遍历数组的同时,cnt[s[i]%k]++;<br>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LL ans = <span class="hljs-number">0</span>;<br>   cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//这个太重要了，这个就相当于s[i]-0;</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>   &#123;<br>       <span class="hljs-comment">//for遍历从1到i-1，判断(s[i] - s[j])%k == 0的数量</span><br>       <span class="hljs-comment">//如果(s[i] - s[j])%k == 0那么s[i]%k == s[j]%k</span><br>       <span class="hljs-comment">//(s[i] + s[j])%k == 0,那么s[i]%k + s[j]%k == k</span><br>       <span class="hljs-type">int</span> t = a[i] % k;<br>       ans += cnt[t]++;<br>   &#125;<br>   cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>差分就一个思想 <strong>插入</strong></p><h2 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a>一维</h2><p><strong>给区间[l, r]中的每个数加上c：B[l] +&#x3D; c, B[r + 1] -&#x3D; c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l]+=c;<br>    b[r+<span class="hljs-number">1</span>]-=c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">insert</span>(i,i,a[i]);<br>    <br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);<br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        sum+=b[i];<br>        a[i]=sum;<br>       <span class="hljs-comment">//b[i]+=b[i-1];</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h2><p>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</p><p><strong>S[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2]+&#x3D;c ；</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[x1][y1] += c;<br>    b[x1][y2+<span class="hljs-number">1</span>] -= c;<br>    b[x2+<span class="hljs-number">1</span>][y1] -= c;<br>    b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] += c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) <span class="hljs-built_in">insert</span>(i,j,i,j,a[i][j]);<br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);<br>        <span class="hljs-built_in">insert</span>(x1,y1,x2,y2,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)  b[i][j]+=b[i<span class="hljs-number">-1</span>][j]+b[i][j<span class="hljs-number">-1</span>]-b[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>        <span class="hljs-comment">//上面就很巧妙</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, b[i][j]);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散化</title>
    <link href="/2022/01/10/Algorithm/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <url>/2022/01/10/Algorithm/%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>值域大，个数小</p><p>两个问题</p><ol><li>重复元素   &gt;  去重</li><li>快速映射   &gt;  二分</li></ol><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//离散化，让大的数变成小的</span><br><span class="hljs-comment">//用vector储存大的数，然后处理大的数a的时候，在vector中找到a，返回vector的下标x</span><br><span class="hljs-comment">//在定义一个数组，a =&gt; x;处理a[x]即可</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><br><br>vector&lt;<span class="hljs-type">int</span>&gt; alls;<br><br>vector&lt;PII&gt; add,query;<br><span class="hljs-type">int</span> a[<span class="hljs-number">300010</span>],s[<span class="hljs-number">300010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>  <span class="hljs-comment">// 找到x </span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l= <span class="hljs-number">0</span>,r=alls.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l+r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(alls[mid]&gt;=x) r=mid; <span class="hljs-comment">//找x的最左边 </span><br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r+<span class="hljs-number">1</span>; <span class="hljs-comment">// 方便前缀和</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x,c;<br>        cin&gt;&gt;x&gt;&gt;c;<br>        add.<span class="hljs-built_in">push_back</span>(&#123;x,c&#125;);<br>        <br>        alls.<span class="hljs-built_in">push_back</span>(x);   <br>    &#125; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        query.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br>        <br>        alls.<span class="hljs-built_in">push_back</span>(l);<br>        alls.<span class="hljs-built_in">push_back</span>(r);<br>        <br>    &#125;<br>    <span class="hljs-comment">//排序 </span><br>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">//去重</span><br>    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-comment">//处理插入</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item : add)<br>    &#123;<br>      <span class="hljs-type">int</span> x=  <span class="hljs-built_in">find</span>(item.first);<br>      a[x] += item.second;<br>    &#125;<br>    <span class="hljs-comment">//预处理前缀和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;= alls.<span class="hljs-built_in">size</span>();i++) s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<br>    <br>    <span class="hljs-comment">//处理询问</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item : query)<br>    &#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(item.first);<br>        <span class="hljs-type">int</span> r = <span class="hljs-built_in">find</span>(item.second);<br><br>        cout&lt;&lt;s[r]-s[l<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><p><img src="/img/Photo/Discrete/01.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将所有存在交集的区间合并</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res; <span class="hljs-comment">//先定义一个新的PII</span><br><br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">//对于pair的排序，先按first，若相等，再按second；</span><br><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs) <span class="hljs-comment">// 新的区间，分开的</span><br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first) <br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed, seg.second); <span class="hljs-comment">//有相交的</span><br><br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;); <span class="hljs-comment">//再把第13行的放进去</span><br><br>    segs = res; <span class="hljs-comment">//更新</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2022/01/02/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2022/01/02/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/Photo/Hash/01.jpeg"></p><p>把大的数据映射到从0到N，和离散化很像</p><p><em><strong>必看</strong></em><a href="https://www.acwing.com/solution/content/30169/"><em><strong>讲解</strong></em></a></p><h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p>用到链表，首先把一个很大的数x通过**(x%N+N)%N**变成较小的数k；</p><p>(N为质数，可以减小冲突)</p><p>k就是头节点；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx ++ ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        <span class="hljs-keyword">if</span> (e[i] == x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p>只用到了一个一维数组，根据经验，数组的范围是题目范围的2~3倍；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200003</span>, null = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> h[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = (x % N + N) % N;<br>    <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<br>    &#123;<br>        t ++ ;<br>        <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> h);<br><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>, op, &amp;x);<br>        <span class="hljs-keyword">if</span> (*op == <span class="hljs-string">&#x27;I&#x27;</span>) h[<span class="hljs-built_in">find</span>(x)] = x;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (h[<span class="hljs-built_in">find</span>(x)] == null) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p>把一串字符看成是一个P进制的数</p><p>根据经验值，P取131或13331，Q取2^64；</p><p>使用场景： 两个字符串的子串是否相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp">核心思想：将字符串看成P进制数，P的经验值是<span class="hljs-number">131</span>或<span class="hljs-number">13331</span>，取这两个值的冲突概率低<br>小技巧：取模的数用<span class="hljs-number">2</span>^<span class="hljs-number">64</span>，这样直接用<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>存储，溢出的结果就是取模的结果<br><br><br><span class="hljs-comment">// h[i]前i个字符的hash值</span><br><span class="hljs-comment">// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字</span><br><span class="hljs-comment">// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, P = <span class="hljs-number">131</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> str[N];<br>ULL h[N], p[N];<br><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str + <span class="hljs-number">1</span>);<br><br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>        p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> l1, r1, l2, r2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(l1, r1) == <span class="hljs-built_in">get</span>(l2, r2)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2021/12/30/Algorithm/%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/12/30/Algorithm/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>基于分治</strong></p><p><strong>快排是先分完再递归两边</strong></p><p><strong>归并是先递归，后合二为一</strong></p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><a href="https://juejin.cn/post/7056416599003136014">有三种快排</a></p><ul><li>挖坑法</li><li>左右指针法</li><li>前后指针法</li></ul><p><em><strong>在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成了两个部分。</strong></em></p><ol><li>找一个参照点x</li><li>让x的左边都小于x，右边都大大于x</li><li>以 J 为中点，递归左边和右边</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//只有一个或为零时，结束 </span><br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>]; <span class="hljs-comment">// 这里的-1和+1会在下面的do循环中去掉 </span><br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x); <span class="hljs-comment">// 找到左边比x大(&gt;=)的数 </span><br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);  <span class="hljs-comment">// 找到右边比x小(&lt;=)的数 </span><br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);  <span class="hljs-comment">//判断是否左边小于右边，然后交换 </span><br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r); <span class="hljs-comment">//递归左右两边 </span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><ol><li>[L,R] &#x3D;&gt; [L,mid]  ,  [mid+1,R] ;</li><li>递归排序[L,mid]和[mid+1,R];</li><li>归并，将左右两个有序序列合并成一个有序序列；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span><span class="hljs-comment">//归并排序</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//先递归，递归到最后 </span><br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-comment">//递归到最后，就是两个数 </span><br><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//左右遍历两个数组 </span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) <span class="hljs-comment">//将这两个数进行比较 </span><br>    <span class="hljs-comment">//tem是一个临时数组 </span><br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];  <br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br>    <span class="hljs-comment">//把剩下的几个的放进去 </span><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br>    <span class="hljs-comment">//再改变q数组 </span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="排序后再恢复"><a href="#排序后再恢复" class="headerlink" title="排序后再恢复"></a>排序后再恢复</h1><p><strong>将某一数组排序，再进行操作后，如何按照原顺序输出</strong></p><p>先看一例题，该题的思路就是排序排序再排序！</p><p><img src="/img/Photo/Sort/01.png"></p><p>该题的思路引入</p><p><img src="/img/Photo/Sort/02.png"></p><p>以该题为例，首先就是要排序，找到相邻距离，方向相对的蚂蚁。</p><p>这里需要用结构体储存位置、方向、编号和永久位置(编号具有大作用，后面会讲)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ant</span>&#123;<br>    <span class="hljs-type">int</span> w,h,id,p;<span class="hljs-comment">//p的用途后面会讲</span><br>    <span class="hljs-comment">//w为位置,h为方向,id为编号,p为相对位置</span><br>&#125;a[N];<br></code></pre></td></tr></table></figure><p><strong>按照位置进行排序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(ant a,ant b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.w&lt;b.w;<br>&#125;<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp1);<br></code></pre></td></tr></table></figure><p>排序之后记录相对位置，相对位置可以理解为蚂蚁们再数轴上的排名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i].p=i;<br></code></pre></td></tr></table></figure><p>再模拟蚂蚁t时间后的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i].w+=a[i].h*t;<br><span class="hljs-comment">//a[i].h为1时向右，位置+</span><br><span class="hljs-comment">//a[i].h为-1时向左，位置-</span><br></code></pre></td></tr></table></figure><p>两个for循环可以写在一块，节约时间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>&#123;<br>    a[i].p=i;<br>    a[i].w+=a[i].h*t;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>模拟t时间后,还是排序,按照位置进行排序</strong></p><p>排序后的蚂蚁的相对位置不会变</p><p>原来是第一位的蚂蚁,还是第一位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp1);<br></code></pre></td></tr></table></figure><p><img src="/img/Photo/Sort/03.png"></p><p>t时间后,如果两个蚂蚁正好相撞,根据题意,这是他们的朝向为0;</p><p>记得判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(a[i].w==a[i+<span class="hljs-number">1</span>].w) <br>    &#123;<br>        a[i].h=a[i+<span class="hljs-number">1</span>].h=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充记录从小到大蚂蚁的位置及方向</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>w[i][<span class="hljs-number">0</span>]=ant[i].w;<br>w[i][<span class="hljs-number">1</span>]=ant[i].f;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>按照输入顺序输出,也就是按照id排序</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp2</span><span class="hljs-params">(ant a,ant b)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">return</span> a.id&lt;b.id;   <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>按照输入时的顺序依次按照各自的永久位置输出每一只蚂蚁的坐标及状态</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>cout&lt;&lt;w[ant[i].d][<span class="hljs-number">0</span>]&lt;&lt;w[ant[i].d][<span class="hljs-number">1</span>]&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p>完整AC代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10010</span>;<br><br><span class="hljs-type">int</span> n,t;<br><span class="hljs-type">int</span> w[N][<span class="hljs-number">2</span>];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ant</span>&#123;<br>    <span class="hljs-type">int</span> w,h,id,p;<span class="hljs-comment">//p的用途后面会讲</span><br>    <span class="hljs-comment">//w为位置,h为方向,id为编号,p为相对位置</span><br>&#125;a[N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp1</span><span class="hljs-params">(ant a,ant b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.w&lt;b.w;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp2</span><span class="hljs-params">(ant a,ant b)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">return</span> a.id&lt;b.id;   <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;t;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>&#123;<br>cin&gt;&gt;a[i].w&gt;&gt;a[i].h;<br>a[i].id=i;<br>&#125;<br><br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp1);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>&#123;<br>    a[i].p=i;<br>    a[i].w+=a[i].h*t;<br>&#125;<br><br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp1);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(a[i].w==a[i+<span class="hljs-number">1</span>].w) <br>    &#123;<br>     a[i].h=a[i+<span class="hljs-number">1</span>].h=<span class="hljs-number">0</span>;<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//按位置记录，就是相对位置</span><br>w[i][<span class="hljs-number">0</span>]=a[i].w;<br>w[i][<span class="hljs-number">1</span>]=a[i].h;<br>&#125;<br><br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp2);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>cout&lt;&lt;w[a[i].p][<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;w[a[i].p][<span class="hljs-number">1</span>]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图和拓扑排序</title>
    <link href="/2021/12/29/%E5%9B%BE/"/>
    <url>/2021/12/29/%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h1><p>树是一种特殊的图，与图的存储方式相同。</p><p>对于无向图中的边a b，存储两条有向边a-&gt;b, b-&gt;a。</p><p>因此我们可以只考虑有向图的存储。</p><p>(1) 邻接矩阵：g[a][b] 存储边a-&gt;b</p><p>(2) <strong>邻接表</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span><br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><br><span class="hljs-comment">// 添加一条边a-&gt;b</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 初始化</span><br>idx = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br><br><span class="hljs-built_in">add</span>(a,b),<span class="hljs-built_in">add</span>(b,a);<br></code></pre></td></tr></table></figure><p><img src="/img/Photo/Graph/01.png"></p><h1 id="树和图的遍历"><a href="#树和图的遍历" class="headerlink" title="树和图的遍历"></a>树和图的遍历</h1><p><strong>时间复杂度 O(n+m), n 表示点数，m 表示边数</strong></p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// st[u] 表示点u已经被遍历过</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j]) <span class="hljs-built_in">dfs</span>(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-comment">//st[1] = true; // 表示1号点已经被遍历过</span><br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> d);<br>d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>&#123;<br>    <br>    <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j])<br>        &#123;<br>            d[j]=d[t]+<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//st[j] = true; // 表示点j已经被遍历过</span><br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>有向无环图就是拓扑图</p><p>是BFS的一种应用</p><p><img src="/img/Photo/Graph/02.png"></p><p>一个无环图一定存在一个入度为0的点。</p><p><img src="/img/Photo/Graph/03.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">// d[i] 存储点i的入度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (!d[i])<br>            q[ ++ tt] = i;<br><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt)<br>    &#123;<br>        <span class="hljs-type">int</span> t = q[hh ++ ];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (-- d[j] == <span class="hljs-number">0</span>)<br>                q[ ++ tt] = j;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span><br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>无论是DFS还是BFS，我们都是把数据想象成一棵树。</p><p>dfs 最重要的是搜索顺序。用什么顺序遍历所有方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n，p[<span class="hljs-number">10</span>];<br><span class="hljs-type">bool</span> s[<span class="hljs-number">10</span>];<span class="hljs-comment">//判断存不存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u==n) <span class="hljs-comment">//结束条件</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cout&lt;&lt;p[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">//空位上可以选的数字1~n;</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(!s[i]) <span class="hljs-comment">//如果数字i没有被用过</span><br>        &#123; <br>            p[u]=i; <span class="hljs-comment">//放入空位置 </span><br>            s[i]=<span class="hljs-number">1</span>; <span class="hljs-comment">//记录状态，已经被用</span><br>            <span class="hljs-built_in">dfs</span>(u+<span class="hljs-number">1</span>); <span class="hljs-comment">//进行下一步搜索</span><br>            s[i]=<span class="hljs-number">0</span>; <span class="hljs-comment">//恢复现场</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列</title>
    <link href="/2021/12/12/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2021/12/12/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>在c++中，有方便的STL，可以直接调用栈和队列，但利用数组模拟栈和队列的效率更高</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><strong>先进先出</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// tt表示栈顶</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[ ++ tt] = x;<br><br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt -- ;<br><br><span class="hljs-comment">// 栈顶的值</span><br>stk[tt];<br><br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">常见模型：找出每个数左边离它最近的比它大/小的数<br><span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>     <span class="hljs-type">int</span> x;<br>     cin&gt;&gt;x;<br>     <span class="hljs-keyword">while</span>(tt&amp;&amp;stack[tt]&gt;=x) tt--; <span class="hljs-comment">//注意=号；</span><br>     <span class="hljs-keyword">if</span>(tt) cout&lt;&lt;stack[tt]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>     <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>     stack[++tt] = x;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><strong>先进后出</strong></p><ol><li>模拟一个队伍，有队头和队尾，从队尾插入是比较难的;</li><li>可以让hh是队头，弹出对头时就++;</li><li>那么队尾就容易模拟，让tt&#x3D;-1;每次队尾加人，就tt++;</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[ ++ tt] = x;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>维护一个队列<code>q[]</code>,<code>q[]</code>数组存储的是下标,<code>hh</code>是队尾，<code>tt</code>是队头</p><p>我们要维护这个队列，要把第i个数加进去之前</p><p>1、要把当前队列中所有不小于第i个数的数全部删去</p><p>使得该队列为单调递增序列</p><p>2、判断队尾是否需要向后移动，就是判断下标<code>q[hh]</code>是否在<code>[i-k+1,i]</code>之间；如果不在的话，<code>hh++</code>；</p><p>进行这两个步骤之后，就可以把下标i加到数组q中去了；即<code>q[++tt]=i</code>;</p><p><strong>小tips</strong>：队尾和对头的关系要进行判断，当<code>hh&lt;=tt</code>这个条件满足时才可以对队头和队尾进行操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//维持一个单调队列,q[hh]是队头，i永远是队尾；</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br><span class="hljs-comment">//与双指针相似，q[hh] 和 i 是两个指针</span><br>&#123;<br>    <span class="hljs-comment">//q[hh]是该k个区间内min，一个单调队列</span><br>    <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) hh ++ ;<br>    <span class="hljs-comment">//只要左边的大，就删去；</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ;<br>    <span class="hljs-comment">//映射，t =&gt; i;</span><br>    q[ ++ tt] = i;<br>    <span class="hljs-comment">//输出</span><br>    <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[hh]]);<br>&#125;<br><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="常见模型：找出滑动窗口中的最大值-x2F-最小值"><a href="#常见模型：找出滑动窗口中的最大值-x2F-最小值" class="headerlink" title="常见模型：找出滑动窗口中的最大值&#x2F;最小值"></a>常见模型：找出滑动窗口中的最大值&#x2F;最小值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">常见模型：找出滑动窗口中的最大值/最小值<br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check_out</span>(q[hh])) hh ++ ;  <span class="hljs-comment">// 判断队头是否滑出窗口</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check</span>(q[tt], i)) tt -- ;<br>    q[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2021/12/07/Algorithm/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2021/12/07/Algorithm/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>位运算 —— 模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">求n的第k位数字: n &gt;&gt; k &amp; <span class="hljs-number">1</span><br>返回n的最后一位<span class="hljs-number">1</span>：<span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br></code></pre></td></tr></table></figure><h1 id="n的二进制表示中第k位是几（从个位算）"><a href="#n的二进制表示中第k位是几（从个位算）" class="headerlink" title="n的二进制表示中第k位是几（从个位算）"></a>n的二进制表示中第k位是几（从个位算）</h1><p>先把第k位移到最后一位  用右移 &gt;&gt;</p><p>看个位是几 n&gt;&gt;k &amp; 1;</p><p>1的话是0000 0001</p><p>除了最后一位，前面全是0，所以可以看出来最后一位是什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n=<span class="hljs-number">10</span>;<br>cout&lt;&lt;(n&gt;&gt;<span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br><span class="hljs-comment">//输出是1，因为10的二进制是1010，右移一位后变成101；</span><br><span class="hljs-comment">//&amp;是  同为1才为1</span><br></code></pre></td></tr></table></figure><h2 id="lowbit-操作-，树状数组的一种操作"><a href="#lowbit-操作-，树状数组的一种操作" class="headerlink" title="lowbit 操作 ，树状数组的一种操作"></a>lowbit 操作 ，树状数组的一种操作</h2><p>lowbit(x) 返回x的最后一位1；</p><p>x&#x3D;1010  lowbit(x) &#x3D; 10;</p><p>x&#x3D;101000  lowbit(x) &#x3D; 1000;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;<br><span class="hljs-comment">//3的二进制是11；</span><br><span class="hljs-type">int</span> t = i&amp;<span class="hljs-number">-1</span>;<br><span class="hljs-comment">//t = 1;</span><br>i -= t;<br><span class="hljs-comment">//i = 2;2的二进制是10；</span><br>t = i&amp;<span class="hljs-number">-1</span>;<br><span class="hljs-comment">//t = 2;</span><br>i -= t;<br></code></pre></td></tr></table></figure><p>x&amp; -x &#x3D;x&amp;(–x+1)</p><p>作用 ： 统计x里面1的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//用lowbit函数统计x里面1的个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-keyword">while</span>(x)<br>    &#123;<br>        x-=x&amp;-x;<br>        s++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>原码，反码和补码</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2021/12/06/%E4%BA%8C%E5%88%86/"/>
    <url>/2021/12/06/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h1><ol><li><p>二分的本质并不是单调性，有单调可以用二分，用二分不一定得是单调；</p></li><li><p>二分的本质是条件和边界；</p></li><li><p>关于要不要加1，就看是l&#x3D;mid还是r&#x3D;mid；</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质  </span><br>​  <br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">while</span> (l &lt; r)  <br>    &#123;  <br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质  </span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> l;  <br>&#125;  <br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">while</span> (l &lt; r)  <br>    &#123;  <br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;  <br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> l;  <br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h1><p><strong>注意</strong></p><ol><li><p>eps的值要比题目中的小数位多2位</p></li><li><p>要注意边界和范围，比如0.01的三次方根</p></li></ol><p>可以让l&#x3D;-10000和r&#x3D;10000</p><p>或者分正负两种情况，让一个的边界去max（1.0，n）或者max（-1.0，n）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质  </span><br>​  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求  </span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)  <br>    &#123;  <br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;  <br>        <span class="hljs-keyword">else</span> l = mid;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> l;  <br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高精度</title>
    <link href="/2021/11/28/Algorithm/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    <url>/2021/11/28/Algorithm/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">      模板</span><br><span class="hljs-comment">vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    if (A.size() &lt; B.size()) return add(B, A);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    vector&lt;int&gt; C;</span><br><span class="hljs-comment">    int t = 0;</span><br><span class="hljs-comment">    for (int i = 0; i &lt; A.size(); i ++ )</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        t += A[i];</span><br><span class="hljs-comment">        if (i &lt; B.size()) t += B[i];</span><br><span class="hljs-comment">        C.push_back(t % 10);</span><br><span class="hljs-comment">        t /= 10;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    if (t) C.push_back(t);</span><br><span class="hljs-comment">    return C;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; C;<br><span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)<br>&#123;<br><span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i];<br><span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t+=B[i];<br><br>C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>t/=<span class="hljs-number">10</span>;<br>  &#125; <br>  <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(t); <span class="hljs-comment">//不要忘记我爱你，t或许是1 </span><br>  <br>  <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string a,b;<br>vector&lt;<span class="hljs-type">int</span>&gt; A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-comment">//下面要注意范围，记得减1，避免越界 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">add</span>(A,B);<br>    <span class="hljs-comment">//记得是倒序输出  思考一下 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//判断大小的函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A,vector&lt;<span class="hljs-type">int</span>&gt; B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        <span class="hljs-keyword">if</span>(A[i]!=B[i]) <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//高精度减法模板</span><br><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> len = A.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len ;i++)<br>    &#123;<br>        t+=A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i]; <br>        C.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);  <span class="hljs-comment">//这里很巧妙 ，就包括了t&lt;0这种情况</span><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t=<span class="hljs-number">-1</span>;  <span class="hljs-comment">//模拟进位</span><br>        <span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();   <span class="hljs-comment">//记得除去前导零</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt;A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B)) <span class="hljs-comment">//先判断大小，执行的是A-B；</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">sub</span>(A,B);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">sub</span>(B,A);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>); <span class="hljs-comment">//如果A&gt;B的话，加个符号就好啦</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//高精度乘法模板</span><br><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A,<span class="hljs-type">int</span> B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; A.<span class="hljs-built_in">size</span>()||t;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>( i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i]*B;  <span class="hljs-comment">//这个判断很妙</span><br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//0*1223 = 0 除去前导零</span><br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    <span class="hljs-type">int</span> b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    cin&gt;&gt;s&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//不要忘记减去0</span><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//高精度除法模板</span><br><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        r=r*<span class="hljs-number">10</span>+A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r%=b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//反转一下，去前导零方便</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//除去前导零</span><br>    <span class="hljs-keyword">return</span> C;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<span class="hljs-type">int</span> b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;<span class="hljs-comment">//r是余数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">div</span>(A,b,r);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    cout&lt;&lt;endl&lt;&lt;r;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
